<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Abstract Types and Subprograms</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert4 {text-decoration: underline; color: rgb(153,0,0) }
    SPAN.delete4 {text-decoration: line-through; color: rgb(153,0,0) }
    SPAN.insert5 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete5 {text-decoration: line-through; color: rgb(0,102,0) }
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.8em; margin-bottom: 0.6em}
    DIV.Indented1 {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 4.3em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.8em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left:  10.2em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,51,153)"><B>Annotated</B></SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)"><B>&nbsp;Ada Reference Manual</B> (Ada 2022 Draft 35)</SPAN> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>3.9.3 Abstract Types and Subprograms</H1>
<div class="paranum"><a name="p1">1/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
[<A NAME="I2504"></A> <A NAME="I2505"></A><A NAME="I2506"></A><A NAME="I2507"></A>An 
<I>abstract type</I> is a tagged type intended for use as an ancestor 
of other types, but which is not allowed to have objects of its own. 
<A NAME="I2508"></A><A NAME="I2509"></A>An <I>abstract subprogram</I> 
is a subprogram that has no body, but is intended to be overridden at 
some point when inherited. Because objects of an abstract type cannot 
be created, a dispatching call to an abstract subprogram always dispatches 
to some overriding body.]&nbsp;</div>
<div class="paranum"><a name="p1.a.1">1.a.1/5</a></div>
<div class="Annotations"><span class="insert5"><B>Term entry:&nbsp;</B><B>abstract 
type</B> &mdash; tagged type intended for use as an ancestor of other 
types, but which is not allowed to have objects of its own</span></div>

<H4 Class="centered">Language Design Principles</H4>
<div class="paranum"><a name="p1.a">1.a/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0299-1.TXT">AI05-0299-1</A></I>} 
An abstract subprogram has no body, so the rules in this subclause are 
designed to ensure (at compile time) that the body will never be invoked. 
We do so primarily by disallowing the creation of values of the abstract 
type. Therefore, since type conversion and parameter passing don't change 
the tag, we know we will never get a class-wide value with a tag identifying 
an abstract type. This means that we only have to disallow nondispatching 
calls on abstract subprograms (dispatching calls will never reach them). 
</div>

<H4 Class="centered">Syntax</H4>
<div class="paranum"><a name="p1.1">1.1/3</a></div>
<div class="Indented1">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-20218.TXT">AI95-00218-03</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0183-1.TXT">AI05-0183-1</A></I>} 
<SPAN Class="swiss">abstract_subprogram_declaration</SPAN><A NAME="I2510"></A><A NAME="S0076"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;[<A NAME="I2511"></A><SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0234">overriding_indicator</A></SPAN>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I2512"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0196">subprogram_specification</A></SPAN>&nbsp;<B>is</B>&nbsp;<B>abstract</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<A NAME="I2513"></A><SPAN Class="swiss"><A HREF="AA-13-1-1.html#S0346">aspect_specification</A></SPAN>];</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p1.2">1.2/2</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<A NAME="I2514"></A><A NAME="I2515"></A>Interface types (see <A HREF="AA-3-9-4.html">3.9.4</A>) 
are abstract types. In addition, a tagged type that has the reserved 
word <B>abstract</B> in its declaration is an abstract type. The class-wide 
type (see <A HREF="AA-3-4-1.html">3.4.1</A>) rooted at an abstract type 
is not itself an abstract type.&nbsp;</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p2">2/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
Only a tagged type shall have the reserved word <B>abstract</B> in its 
declaration.&nbsp;</div>
<div class="paranum"><a name="p2.a">2.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Untagged types are never 
abstract, even though they can have primitive abstract subprograms. Such 
subprograms cannot be called, unless they also happen to be dispatching 
operations of some tagged type, and then only via a dispatching call.</div>
<div class="paranum"><a name="p2.b">2.b</a></div>
<div class="Annotations">Class-wide types are never abstract. If T is 
abstract, then it is illegal to declare a stand-alone object of type 
T, but it is OK to declare a stand-alone object of type T'Class; the 
latter will get a tag from its initial value, and this tag will necessarily 
be different from T'Tag.&nbsp;</div>
<div class="paranum"><a name="p3">3/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
<A NAME="I2516"></A><A NAME="I2517"></A>A subprogram declared by an <SPAN Class="swiss"><A HREF="AA-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN> 
or a <SPAN Class="swiss"><A HREF="AA-12-6.html#S0337">formal_abstract_subprogram_declaration</A></SPAN> 
(see <A HREF="AA-12-6.html">12.6</A>) is an <I>abstract subprogram</I>. 
If it is a primitive subprogram of a tagged type, then the tagged type 
shall be abstract.&nbsp;</div>
<div class="paranum"><a name="p3.a">3.a</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>Ramification: 
</B>Note that for a private type, this applies to both views. The following 
is illegal:&nbsp;</div>
<div class="paranum"><a name="p3.b">3.b</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>abstract</B>&nbsp;<B>tagged</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Foo&nbsp;(X&nbsp;:&nbsp;T)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B>&nbsp;<B>abstract</B>;&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN><BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;Foo&nbsp;(T'Class&nbsp;(X));<BR>
<B>end</B>&nbsp;P;</div>
<div class="paranum"><a name="p3.c">3.c</a></div>
<div class="Annotations">The full view of T is not abstract, but has 
an abstract operation Foo, which is illegal. The two lines marked &quot;--<I>&nbsp;Illegal!</I>&quot; are illegal when taken together.&nbsp;</div>
<div class="paranum"><a name="p3.d">3.d/2</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00310.TXT">AI95-00310-01</A></I>} 
We considered disallowing untagged types from having abstract primitive 
subprograms. However, we rejected that plan, because it introduced some 
silly anomalies, and because such subprograms are harmless. For example: 
</div>
<div class="paranum"><a name="p3.e">3.e/1</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Field_Size&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;0..100;<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>abstract&nbsp;tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Print(X&nbsp;:&nbsp;<B>in</B>&nbsp;T;&nbsp;F&nbsp;:&nbsp;<B>in</B>&nbsp;Field_Size&nbsp;:=&nbsp;0)&nbsp;<B>is</B>&nbsp;<B>abstract</B>;<BR>
&nbsp;&nbsp;.&nbsp;.&nbsp;.<BR>
<B>package</B>&nbsp;Q&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;My_Field_Size&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Field_Size;<BR>
&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;implicit&nbsp;declaration&nbsp;of&nbsp;Print(X&nbsp;:&nbsp;T;&nbsp;F&nbsp;:&nbsp;My_Field_Size&nbsp;:=&nbsp;0)&nbsp;<B>is&nbsp;abstract</B>;</I></SPAN><BR>
<B>end</B>&nbsp;Q;</div>
<div class="paranum"><a name="p3.f">3.f</a></div>
<div class="Annotations">It seemed silly to make the derivative of My_Field_Size 
illegal, just because there was an implicitly declared abstract subprogram 
that was not primitive on some tagged type. Other rules could be formulated 
to solve this problem, but the current ones seem like the simplest.</div>
<div class="paranum"><a name="p3.g">3.g/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00310.TXT">AI95-00310-01</A></I>} 
In Ada 2005, abstract primitive subprograms of an untagged type may be 
used to &ldquo;undefine&rdquo; an operation.&nbsp;</div>
<div class="paranum"><a name="p3.h">3.h/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
Note that the second sentence does not apply to abstract formal subprograms, 
as they are never primitive operations of a type.&nbsp;</div>
<div class="paranum"><a name="p4">4/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00334.TXT">AI95-00334-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0097-1.TXT">AI05-0097-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0198-1.TXT">AI05-0198-1</A></I>} 
If a type has an implicitly declared primitive subprogram that is inherited 
or is a predefined operator, and the corresponding primitive subprogram 
of the parent or ancestor type is abstract or is a function with a controlling 
access result, or if a type other than a nonabstract null extension inherits 
a function with a controlling result, then:&nbsp;</div>
<div class="paranum"><a name="p4.a">4.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0068-1.TXT">AI05-0068-1</A></I>} 
These rules apply to each view of the type individually. That is necessary 
to preserve privacy. For instance, in the following example:&nbsp;</div>
<div class="paranum"><a name="p4.b">4.b/3</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;I&nbsp;<B>is&nbsp;interface</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op&nbsp;(X&nbsp;:&nbsp;I)&nbsp;<B>is&nbsp;abstract</B>;<BR>
<B>end</B>&nbsp;P;</div>
<div class="paranum"><a name="p4.c">4.c/3</a></div>
<div class="SmallExamples"><B>with</B>&nbsp;P;<BR>
<B>package</B>&nbsp;Q&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;abstract&nbsp;new</B>&nbsp;P.I&nbsp;<B>with&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>Op&nbsp;inherited&nbsp;here.</I></SPAN><BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;abstract&nbsp;new</B>&nbsp;P.I&nbsp;<B>with&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op&nbsp;(X&nbsp;:&nbsp;T)&nbsp;<B>is&nbsp;null</B>;<BR>
<B>end</B>&nbsp;Q;</div>
<div class="paranum"><a name="p4.d">4.d/3</a></div>
<div class="SmallExamples"><B>with</B>&nbsp;Q;<BR>
<B>package</B>&nbsp;R&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is&nbsp;new</B>&nbsp;Q.T&nbsp;<B>with&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal.&nbsp;Op&nbsp;inherited&nbsp;here,&nbsp;but&nbsp;requires&nbsp;overriding.</I></SPAN><BR>
<B>end</B>&nbsp;R;</div>
<div class="paranum"><a name="p4.e">4.e/3</a></div>
<div class="Annotations">If this did not depend on the view, this would 
be legal. But in that case, the fact that Op is overridden in the private 
part would be visible; package R would have to be illegal if no overriding 
was in the private part.</div>
<div class="paranum"><a name="p4.f">4.f/3</a></div>
<div class="Annotations">Note that this means that whether an inherited 
subprogram is abstract or concrete depends on where it inherited. In 
the case of Q, Q.Op in the visible part is abstract, while Q.Op in the 
private part is concrete. That is, R is illegal since it is an unrelated 
unit (and thus it cannot see the private part), but if R had been a private 
child of Q, it would have been legal.&nbsp;</div>
<div class="paranum"><a name="p5">5/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00334.TXT">AI95-00334-01</A></I>} 
If the type is abstract or untagged, the implicitly declared subprogram 
is <I>abstract</I>.&nbsp;</div>
<div class="paranum"><a name="p5.a">5.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Note that it is possible 
to override a concrete subprogram with an abstract one.&nbsp;</div>
<div class="paranum"><a name="p6">6/5</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0080-1.TXT">AI12-0080-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0444-1.TXT">AI12-0444-1</A></I>} 
Otherwise, the subprogram shall be overridden with a nonabstract subprogram 
or, in the case of a private extension inheriting a <span class="insert4">nonabstract 
</span>function with a controlling result, have a full type that is a 
null extension[; for a type declared in the visible part of a package, 
the overriding may be either in the visible or the private part]. Such 
a subprogram is said to <I>require overriding</I>.<A NAME="I2518"></A> 
However, if the type is a generic formal type, the subprogram <span class="insert5">is 
allowed to be inherited as is, without being</span><span class="delete5">&nbsp;need 
not be</span> overridden for the formal type itself; [a nonabstract version 
will necessarily be provided by the actual type.]&nbsp;</div>
<div class="paranum"><a name="p6.a">6.a/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00228.TXT">AI95-00228-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
A function that returns the parent type requires overriding for a type 
extension (or becomes abstract for an abstract type) because conversion 
from a parent type to a type extension is not defined, and function return 
semantics is defined in terms of conversion (other than for a null extension; 
see below). (Note that parameters of mode <B>in out</B> or <B>out</B> 
do not have this problem, because the tag of the actual is not changed.)</div>
<div class="paranum"><a name="p6.b">6.b</a></div>
<div class="Annotations" style="margin-bottom: 0.4em">Note that the 
overriding required above can be in the private part, which allows the 
following:&nbsp;</div>
<div class="paranum"><a name="p6.c">6.c</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;Pack1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Ancestor&nbsp;<B>is</B>&nbsp;<B>abstract</B>&nbsp;...;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Do_Something(X&nbsp;:&nbsp;<B>in</B>&nbsp;Ancestor)&nbsp;<B>is</B>&nbsp;<B>abstract</B>;<BR>
<B>end</B>&nbsp;Pack1;</div>
<div class="paranum"><a name="p6.d">6.d</a></div>
<div class="SmallExamples"><B>with</B>&nbsp;Pack1;&nbsp;<B>use</B>&nbsp;Pack1;<BR>
<B>package</B>&nbsp;Pack2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ancestor&nbsp;<B>with</B>&nbsp;<B>record</B>&nbsp;...;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;A&nbsp;concrete&nbsp;type.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Do_Something(X&nbsp;:&nbsp;<B>in</B>&nbsp;T1);&nbsp;--<SPAN Class="roman"><I>&nbsp;Have&nbsp;to&nbsp;override.</I></SPAN><BR>
<B>end</B>&nbsp;Pack2;</div>
<div class="paranum"><a name="p6.e">6.e</a></div>
<div class="SmallExamples"><B>with</B>&nbsp;Pack1;&nbsp;<B>use</B>&nbsp;Pack1;<BR>
<B>with</B>&nbsp;Pack2;&nbsp;<B>use</B>&nbsp;Pack2;<BR>
<B>package</B>&nbsp;Pack3&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ancestor&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;A&nbsp;concrete&nbsp;type.</I></SPAN><BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1&nbsp;<B>with</B>&nbsp;--<SPAN Class="roman"><I>&nbsp;Parent&nbsp;different&nbsp;from&nbsp;ancestor.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Here,&nbsp;we&nbsp;inherit&nbsp;Pack2.Do_Something.</I></SPAN><BR>
<B>end</B>&nbsp;Pack3;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div class="paranum"><a name="p6.f">6.f/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00228.TXT">AI95-00228-01</A></I>} 
T2 inherits an abstract Do_Something, but T2 is not abstract, so Do_Something 
has to be overridden. However, it is OK to override it in the private 
part. In this case, we override it by inheriting a concrete version from 
a different type. Nondispatching calls to Pack3.Do_Something are allowed 
both inside and outside package Pack3, as the client &ldquo;knows&rdquo; 
that the subprogram was necessarily overridden somewhere.</div>
<div class="paranum"><a name="p6.g">6.g/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
For a null extension, the result of a function with a controlling result 
is defined in terms of an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0111">extension_aggregate</A></SPAN> 
with a <B>null record</B> extension part (see <A HREF="AA-3-4.html">3.4</A>). 
This means that these restrictions on functions with a controlling result 
do not have to apply to null extensions.</div>
<div class="paranum"><a name="p6.h">6.h/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
However, functions with controlling access results still require overriding. 
Changing the tag in place might clobber a preexisting object, and allocating 
new memory would possibly change the pool of the object, leading to storage 
leaks. Moreover, copying the object isn't possible for limited types. 
We don't need to restrict functions that have an access return type of 
an untagged type, as derived types with primitive subprograms have to 
have the same representation as their parent type.&nbsp;</div>
<div class="paranum"><a name="p7">7/5</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
A call on an abstract subprogram shall be a dispatching call; nondispatching 
calls to an abstract subprogram are not allowed.<span class="insert5">&nbsp;<A NAME="I2519"></A>In addition to the places where Legality Rules normally 
apply (see <A HREF="AA-12-3.html">12.3</A>), these rules also apply in 
the private part of an instance of a generic unit.</span>&nbsp;</div>
<div class="paranum"><a name="p7.a">7.a/5</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00310.TXT">AI95-00310-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
If an abstract subprogram is not a dispatching operation of some tagged 
type, then it cannot be called at all. In Ada 2005, such subprograms 
are not even considered by name resolution (see <A HREF="AA-6-4.html">6.4</A>).<span class="insert5">&nbsp;However, this rule is still needed for cases that can arise in the instance 
of a generic specification where Name Resolution Rules are not reapplied, 
but Legality Rules are, when the equality operator for an untagged record 
type is abstract, while the operator for the formal type is not abstract 
(see <A HREF="AA-12-5.html">12.5</A>).</span>&nbsp;</div>
<div class="paranum"><a name="p7.1">7.1/5</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0189-1.TXT">AI12-0189-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0292-1.TXT">AI12-0292-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0320-1.TXT">AI12-0320-1</A></I>} 
<span class="insert5">If the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
given in an <SPAN Class="swiss"><A HREF="AA-5-5-3.html#S0187">iterator_procedure_call</A></SPAN> 
(see <A HREF="AA-5-5-3.html">5.5.3</A>) denotes an abstract subprogram, 
the subprogram shall be a dispatching subprogram.</span></div>
<div class="paranum"><a name="p8">8/5</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0073-1.TXT">AI05-0073-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0203-1.TXT">AI05-0203-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0437-1.TXT">AI12-0437-1</A></I>} 
The type of an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>, 
<span class="delete5">or&nbsp;</span>of an object created by an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
or an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0164">allocator</A></SPAN>, 
or <span class="insert5">of&nbsp;</span>a generic formal object of mode <B>in</B>, 
shall not be abstract. The type of the target of an assignment operation 
(see <A HREF="AA-5-2.html">5.2</A>) shall not be abstract. The type of 
a component shall not be abstract. If the result type of a function is 
abstract, then the function shall be abstract. If a function has an access 
result type designating an abstract type, then the function shall be 
abstract. The type denoted by a <SPAN Class="swiss"><A HREF="AA-6-5.html#S0226">return_subtype_indication</A></SPAN> 
(see <A HREF="AA-6-5.html">6.5</A>) shall not be abstract. A generic 
function shall not have an abstract result type or an access result type 
designating an abstract type.&nbsp;</div>
<div class="paranum"><a name="p8.a">8.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>This ensures that values of an 
abstract type cannot be created, which ensures that a dispatching call 
to an abstract subprogram will not try to execute the nonexistent body.</div>
<div class="paranum"><a name="p8.b">8.b</a></div>
<div class="Annotations">Generic formal objects of mode <B>in</B> are 
like constants; therefore they should be forbidden for abstract types. 
Generic formal objects of mode <B>in out</B> are like renamings; therefore, 
abstract types are OK for them, though probably not terribly useful.</div>
<div class="paranum"><a name="p8.c">8.c/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0073-1.TXT">AI05-0073-1</A></I>} 
Generic functions returning a formal abstract type are illegal because 
any instance would have to be instantiated with a nonabstract type in 
order to avoid violating the function rule (generic functions cannot 
be declared abstract). But that would be an implied contract; it would 
be better for the contract to be explicit by the formal type not being 
declared abstract. Moreover, the implied contract does not add any capability. 
</div>
<div class="paranum"><a name="p9">9</a></div>
<div class="Normal">If a partial view is not abstract, the corresponding 
full view shall not be abstract. If a generic formal type is abstract, 
then for each primitive subprogram of the formal that is not abstract, 
the corresponding primitive subprogram of the actual shall not be abstract. 
</div>
<div class="paranum"><a name="p9.a">9.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>By contrast, we allow the 
actual type to be nonabstract even if the formal type is declared abstract. 
Hence, the most general formal tagged type possible is &quot;<B>type</B> 
T(&lt;&gt;) <B>is abstract tagged limited private</B>;&quot;.</div>
<div class="paranum"><a name="p9.b">9.b</a></div>
<div class="Annotations">For an abstract private extension declared in 
the visible part of a package, it is only possible for the full type 
to be nonabstract if the private extension has no abstract dispatching 
operations.&nbsp;</div>
<div class="paranum"><a name="p9.c">9.c/2</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>To be honest: 
</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00294.TXT">AI95-00294-01</A></I>} 
In the sentence about primitive subprograms above, there is some ambiguity 
as to what is meant by &ldquo;corresponding&rdquo; in the case where 
an inherited operation is overridden.  This is best explained by an example, 
where the implicit declarations are shown as comments:&nbsp;</div>
<div class="paranum"><a name="p9.d">9.d/2</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;P1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;P&nbsp;(X&nbsp;:&nbsp;T1);&nbsp;--&nbsp;<SPAN Class="roman"><I>(1)</I></SPAN><BR>
<B>end</B>&nbsp;P1;</div>
<div class="paranum"><a name="p9.e">9.e/2</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;P2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is&nbsp;abstract&nbsp;new</B>&nbsp;P1.T1&nbsp;<B>with&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I><B>procedure</B>&nbsp;P&nbsp;(X&nbsp;:&nbsp;T2);&nbsp;--&nbsp;(2)</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;P&nbsp;(X&nbsp;:&nbsp;T2)&nbsp;<B>is&nbsp;abstract</B>;&nbsp;--&nbsp;(3)<BR>
end&nbsp;P2;</div>
<div class="paranum"><a name="p9.f">9.f/2</a></div>
<div class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;D&nbsp;<B>is&nbsp;abstract&nbsp;new</B>&nbsp;P1.T1&nbsp;<B>with&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I><B>procedure</B>&nbsp;P&nbsp;(X&nbsp;:&nbsp;D);&nbsp;--&nbsp;(4)</I></SPAN><BR>
<B>procedure</B>&nbsp;G&nbsp;(X&nbsp;:&nbsp;D);</div>
<div class="paranum"><a name="p9.g">9.g/2</a></div>
<div class="SmallExamples"><B>procedure</B>&nbsp;I&nbsp;<B>is&nbsp;new</B>&nbsp;G&nbsp;(P2.T2);&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal.</I></SPAN></div>
<div class="paranum"><a name="p9.h">9.h/2</a></div>
<div class="Annotations">Type T2 inherits a nonabstract procedure P (2) 
from the primitive procedure P (1) of T1. P (2) is overridden by the 
explicitly declared abstract procedure P (3). Type D inherits a nonabstract 
procedure P (4) from P (1). In instantiation I, the operation corresponding 
to P (4) is the one which is not overridden, that is, P (3): the overridden 
operation P (2) does not &ldquo;reemerge&rdquo;. Therefore, the instantiation 
is illegal.&nbsp;</div>
<div class="paranum"><a name="p10">10/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0073-1.TXT">AI05-0073-1</A></I>} 
For an abstract type declared in a visible part, an abstract primitive 
subprogram shall not be declared in the private part, unless it is overriding 
an abstract subprogram implicitly declared in the visible part. For a 
tagged type declared in a visible part, a primitive function with a controlling 
result or a controlling access result shall not be declared in the private 
part, unless it is overriding a function implicitly declared in the visible 
part.&nbsp;</div>
<div class="paranum"><a name="p10.a">10.a</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>The 
&ldquo;visible part&rdquo; could be that of a package or a generic package. 
This rule is needed because a nonabstract type extension declared outside 
the package would not know about any abstract primitive subprograms or 
primitive functions with controlling results declared in the private 
part, and wouldn't know that they need to be overridden with nonabstract 
subprograms. The rule applies to a tagged record type or record extension 
declared in a visible part, just as to a tagged private type or private 
extension. The rule applies to explicitly and implicitly declared abstract 
subprograms:&nbsp;</div>
<div class="paranum"><a name="p10.b">10.b</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;Pack&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>abstract</B>&nbsp;<B>new</B>&nbsp;T1&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>abstract</B>&nbsp;<B>new</B>&nbsp;T2&nbsp;<B>with</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
<B>end</B>&nbsp;Pack;</div>
<div class="paranum"><a name="p10.c">10.c</a></div>
<div class="Annotations">The above example would be illegal if T1 has 
a nonabstract primitive procedure P, but T2 overrides P with an abstract 
one; the private part should override P with a nonabstract version. On 
the other hand, if the P were abstract for both T1 and T2, the example 
would be legal as is.&nbsp;</div>
<div class="paranum"><a name="p11">11/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
A generic actual subprogram shall not be an abstract subprogram unless 
the generic formal subprogram is declared by a <SPAN Class="swiss"><A HREF="AA-12-6.html#S0337">formal_abstract_subprogram_declaration</A></SPAN>. 
The <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for the Access, Unchecked_Access, or Address attributes shall not denote 
an abstract subprogram.&nbsp;</div>
<div class="paranum"><a name="p11.a">11.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>An <SPAN Class="swiss"><A HREF="AA-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN> 
is not syntactically a <SPAN Class="swiss"><A HREF="AA-6-1.html#S0195">subprogram_declaration</A></SPAN>. 
Nonetheless, an abstract subprogram is a subprogram, and an <SPAN Class="swiss"><A HREF="AA-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN> 
is a declaration of a subprogram.</div>
<div class="paranum"><a name="p11.b">11.b/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
The part about generic actual subprograms includes those given by default. 
Of course, an abstract formal subprogram's actual subprogram can be abstract. 
</div>

<H4 Class="centered">Dynamic Semantics</H4>
<div class="paranum"><a name="p11.1">11.1/2</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
<A NAME="I2520"></A>The elaboration of an <SPAN Class="swiss"><A HREF="AA-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN> 
has no effect.&nbsp;</div>
<div class="paranum"><a name="p12">12/5</a></div>
<div class="Notes">NOTE 1&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0447-1.TXT">AI12-0447-1</A></I>} 
Abstractness is not inherited; <span class="insert5">a type is abstract 
only if</span><span class="delete5">&nbsp;to declare an abstract type,</span> 
the reserved word <B>abstract</B> <span class="insert5">is</span><span class="delete5">&nbsp;has 
to be</span> used in the declaration of the type extension.&nbsp;</div>
<div class="paranum"><a name="p12.a">12.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A derived type can be abstract 
even if its parent is not. Similarly, an inherited concrete subprogram 
can be overridden with an abstract subprogram.&nbsp;</div>
<div class="paranum"><a name="p13">13</a></div>
<div class="Notes">NOTE 2&nbsp;&nbsp;&nbsp;A class-wide type is never 
abstract. Even if a class is rooted at an abstract type, the class-wide 
type for the class is not abstract, and an object of the class-wide type 
can be created; the tag of such an object will identify some nonabstract 
type in the class.&nbsp;</div>

<H4 Class="centered">Examples</H4>
<div class="paranum"><a name="p14">14</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><I>Example of an abstract 
type representing a set of natural numbers:</I>&nbsp;</div>
<div class="paranum"><a name="p15">15</a></div>
<div class="Examples"><B>package</B>&nbsp;Sets&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>subtype</B>&nbsp;Element_Type&nbsp;<B>is</B>&nbsp;Natural;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Empty&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Union(Left,&nbsp;Right&nbsp;:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Intersection(Left,&nbsp;Right&nbsp;:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Unit_Set(Element&nbsp;:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Take(Element&nbsp;:&nbsp;<B>out</B>&nbsp;Element_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Set)&nbsp;<B>is&nbsp;abstract</B>;<BR>
<B>end</B>&nbsp;Sets;</div>
<div class="paranum"><a name="p16">16/5</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0442-1.TXT">AI12-0442-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0452-1.TXT">AI12-0452-1</A></I>} 
<span class="insert5">Given the above abstract type, one can derive various 
(nonabstract) extensions of the type, representing alternative implementations 
of a set. One possibility is to use a bit vector, but impose an upper 
bound on the largest element representable, while another possible implementation 
is a hash table, trading off space for flexibility.</span></div>
<div class="paranum"><a name="p17">17/5</a></div>
<div class="Notes">NOTE 3&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0452-1.TXT">AI12-0452-1</A></I>} 
<span class="delete5"><I>Notes on the example:</I> Given the above abstract 
type, one could then derive various (nonabstract) extensions of the type, 
representing alternative implementations of a set. One might use a bit 
vector, but impose an upper bound on the largest element representable, 
while another might use a hash table, trading off space for flexibility.</span> 
</div>
<div class="paranum"><a name="p17.a">17.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>One way to export a type 
from a package with some components visible and some components private 
is as follows:&nbsp;</div>
<div class="paranum"><a name="p17.b">17.b</a></div>
<div class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Public_Part&nbsp;<B>is</B>&nbsp;<B>abstract</B>&nbsp;<B>tagged</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Public_Part&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Public_Part&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;P;</div>
<div class="paranum"><a name="p17.c">17.c</a></div>
<div class="Annotations">The fact that Public_Part is abstract tells 
clients they have to create objects of type T instead of Public_Part. 
Note that the public part has to come first; it would be illegal to declare 
a private type Private_Part, and then a record extension T of it, unless 
T were in the private part after the full declaration of Private_Part, 
but then clients of the package would not have visibility to T.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 95</H4>
<div class="paranum"><a name="p17.d">17.d/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
<A NAME="I2521"></A>It is not necessary to override functions with a 
controlling result for a null extension. This makes it easier to derive 
a tagged type to complete a private type.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum"><a name="p17.e">17.e/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
Updated the wording to reflect the addition of interface types (see <A HREF="AA-3-9-4.html">3.9.4</A>).</div>
<div class="paranum"><a name="p17.f">17.f/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
Updated the wording to reflect the addition of abstract formal subprograms 
(see <A HREF="AA-12-6.html">12.6</A>).</div>
<div class="paranum"><a name="p17.g">17.g/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00334.TXT">AI95-00334-01</A></I>} 
The wording of shall-be-overridden was clarified so that it clearly applies 
to abstract predefined equality.</div>
<div class="paranum"><a name="p17.h">17.h/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
Moved the syntax and elaboration rule for <SPAN Class="swiss"><A HREF="AA-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN> 
here, so the syntax and most of the semantics are together (which is 
consistent with null procedures).</div>
<div class="paranum"><a name="p17.i">17.i/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
We define the term <I>require overriding</I> to make other wording easier 
to understand.&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 2005</H4>
<div class="paranum"><a name="p17.j">17.j/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0073-1.TXT">AI05-0073-1</A></I>} 
<A NAME="I2522"></A><B>Correction:</B> Added rules to eliminate holes 
with controlling access results and generic functions that return abstract 
types. While these changes are technically incompatible, it is unlikely 
that they could be used in a program without violating some other rule 
of the use of abstract types.</div>
<div class="paranum"><a name="p17.k">17.k/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0097-1.TXT">AI05-0097-1</A></I>} 
<B>Correction:</B> Corrected a minor glitch having to do with abstract 
null extensions. The Ada 2005 rule allowed such extensions to inherit 
concrete operations in some rare cases. It is unlikely that these cases 
exist in user code.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 2005</H4>
<div class="paranum"><a name="p17.l">17.l/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0183-1.TXT">AI05-0183-1</A></I>} 
<A NAME="I2523"></A>An optional <SPAN Class="swiss"><A HREF="AA-13-1-1.html#S0346">aspect_specification</A></SPAN> 
can be used in an <SPAN Class="swiss"><A HREF="AA-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN>. 
This is described in <A HREF="AA-13-1-1.html">13.1.1</A>.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2005</H4>
<div class="paranum"><a name="p17.m">17.m/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0198-1.TXT">AI05-0198-1</A></I>} 
<B>Correction:</B> Clarified that the predefined operator corresponding 
to an inherited abstract operator is also abstract. The Ada 2005 rules 
caused the predefined operator and the inherited operator to override 
each other, which is weird. But the effect is the same either way (the 
operator is not considered for resolution).</div>
<div class="paranum"><a name="p17.n">17.n/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0203-1.TXT">AI05-0203-1</A></I>} 
<B>Correction:</B> Added wording to disallow abstract return objects. 
These were illegal in Ada 2005 by other rules; the extension to support 
class-wide type better opened a hole which has now been plugged.&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 2012</H4>
<div class="paranum"><a name="p17.o">17.o/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
<span class="insert5"><A NAME="I2524"></A><B>Correction:</B> Clarified 
that a recheck is needed in the case of an actual that is a record type 
with an abstract equality. This is an incompatibility as the generic 
boilerplate was previously omitted, meaning that such a recheck should 
not have been performed in the private part of an instance. Usually, 
this would just change an elaboration time raise of Program_Error into 
an error (a good thing, as the instance will never be useful), but could 
break a working instance if the equality usage is in a default expression 
that appears in the private part of the generic unit and it is never 
used in a call. In that case, Ada 2022 will reject the instance while 
it would have worked in Ada 2012. As a practical matter, it's more likely 
that a compiler already does the recheck in the entire instance spec, 
or does not do it at all; thus for many implementations there will be 
no practical incompatibility.</span>&nbsp;</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
