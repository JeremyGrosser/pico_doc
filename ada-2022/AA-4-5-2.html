<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Relational Operators and Membership Tests</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert4 {text-decoration: underline; color: rgb(153,0,0) }
    SPAN.delete4 {text-decoration: line-through; color: rgb(153,0,0) }
    SPAN.insert5 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete5 {text-decoration: line-through; color: rgb(0,102,0) }
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.8em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 4.3em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.8em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left:  10.2em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.SmallBulleted-NoPrefix {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 9.3em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 9.3em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.Indented2NestedBulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Indented2NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.8em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,51,153)"><B>Annotated</B></SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)"><B>&nbsp;Ada Reference Manual</B> (Ada 2022 Draft 35)</SPAN> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>4.5.2 Relational Operators and Membership Tests</H1>
<div class="paranum"><a name="p1">1</a></div>
<div class="Normal">[<A NAME="I3286"></A><A NAME="I3287"></A> <A NAME="I3288"></A><A NAME="I3289"></A><A NAME="I3290"></A>The 
<I>equality operators</I> = (equals) and /= (not equals) are predefined 
for nonlimited types. <A NAME="I3291"></A><A NAME="I3292"></A>The other 
<SPAN Class="swiss"><A HREF="AA-4-5.html#S0143">relational_operator</A></SPAN>s 
are the <I>ordering operators</I> &lt; (less than), &lt;= (less than 
or equal), &gt; (greater than), and &gt;= (greater than or equal). <A NAME="I3293"></A><A NAME="I3294"></A><A NAME="I3295"></A><A NAME="I3296"></A><A NAME="I3297"></A><A NAME="I3298"></A><A NAME="I3299"></A><A NAME="I3300"></A><A NAME="I3301"></A><A NAME="I3302"></A><A NAME="I3303"></A><A NAME="I3304"></A><A NAME="I3305"></A><A NAME="I3306"></A><A NAME="I3307"></A><A NAME="I3308"></A><A NAME="I3309"></A><A NAME="I3310"></A><A NAME="I3311"></A><A NAME="I3312"></A><A NAME="I3313"></A><A NAME="I3314"></A><A NAME="I3315"></A><A NAME="I3316"></A><A NAME="I3317"></A>The 
ordering operators are predefined for scalar types, and for <I>discrete 
array types</I>, that is, one-dimensional array types whose components 
are of a discrete type.&nbsp;</div>
<div class="paranum"><a name="p1.a">1.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The equality operators 
are not defined for <I>every</I> nonlimited type &mdash; see below for 
the exact rule.&nbsp;</div>
<div class="paranum"><a name="p2">2/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0269-1.TXT">AI05-0269-1</A></I>} 
<A NAME="I3318"></A><A NAME="I3319"></A><A NAME="I3320"></A>A <I>membership 
test</I>, using <B>in</B> or <B>not in</B>, determines whether or not 
a value belongs to any given subtype or range, is equal to any given 
value, has a tag that identifies a type that is covered by a given type, 
or is convertible to and has an accessibility level appropriate for a 
given access type. Membership tests are allowed for all types.]</div>

<H4 Class="centered">Name Resolution Rules</H4>
<div class="paranum"><a name="p3">3/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
<A NAME="I3321"></A><A NAME="I3322"></A>The <I>tested type</I> of a membership 
test is determined by the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>s 
of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0136">membership_choice_list</A></SPAN>. 
Either all <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>s 
of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0136">membership_choice_list</A></SPAN> 
shall resolve to the same type, which is the tested type; or each <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN> 
shall be of an elementary type, and the tested type shall be covered 
by each of these elementary types.</div>
<div class="paranum"><a name="p3.1">3.1/5</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0418-1.TXT">AI12-0418-1</A></I>} 
If the tested type is tagged, then the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
shall resolve to be of a type that is convertible (see <A HREF="AA-4-6.html">4.6</A>) 
to the tested type; if untagged, the expected type <span class="insert5">of</span><span class="delete5">&nbsp;for</span> 
the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is the tested type. The expected type of a <span class="insert4"><I>choice_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0133">&nbsp;choice_expression</A></SPAN></span> 
in a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>, 
and of a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
in a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>, 
is the tested type of the membership operation.</div>
<div class="paranum"><a name="p3.a">3.a/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
The part of the rule for untagged types is stated in a way that ensures 
that operands like a string literal are still legal as operands of a 
membership test.</div>
<div class="paranum"><a name="p3.b">3.b/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
The significance of &ldquo;is convertible to&rdquo; is that we allow 
the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
to be of any class-wide type that could be converted to the tested type, 
not just the one rooted at the tested type. This includes any class-wide 
type that covers the tested type, along with class-wide interfaces in 
some cases.</div>
<div class="paranum"><a name="p3.c">3.c/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
The special rule for determining the tested type for elementary types 
is to allow numeric literals in <SPAN Class="swiss"><A HREF="AA-4-4.html#S0136">membership_choice_list</A></SPAN>s. 
Without the rule, <TT>A <B>in</B> B | 1</TT> would be illegal as B and 
1 would have different types (the literal having type <I>universal integer</I>). 
</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p4">4/4</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
For a membership test, if the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is of a tagged class-wide type, then the tested type shall be (visibly) 
tagged.&nbsp;</div>
<div class="paranum"><a name="p4.a">4.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Untagged types covered 
by the tagged class-wide type are not permitted. Such types can exist 
if they are descendants of a private type whose full type is tagged. 
This rule is intended to avoid confusion since such derivatives don't 
have their &ldquo;own&rdquo; tag, and hence are indistinguishable from 
one another at run time once converted to a covering class-wide type. 
</div>
<div class="paranum"><a name="p4.1">4.1/5</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0328-1.TXT">AI12-0328-1</A></I>} 
If a membership test includes one or more <span class="insert4"><I>choice_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN>s</span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0133">&nbsp;choice_expression</A></SPAN>s</span> 
and the tested type of the membership test is limited, then the tested 
type of the membership test shall have a visible primitive equality operator<span class="insert5">; 
if the tested type of the membership test is nonlimited with a user-defined 
primitive equality operator that is defined at a point where the type 
is limited, the tested type shall be a record type or record extension</span>. 
</div>
<div class="paranum"><a name="p4.b">4.b/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
A visible equality operator is required in order to avoid breaking privacy; 
that is, we don't want to depend on a hidden equality operator.</div>
<div class="paranum"><a name="p4.c">4.c/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0328-1.TXT">AI12-0328-1</A></I>} 
<span class="insert5">We make the membership test on the nonlimited view 
of a type illegal if it would use a different equality operator than 
what would be used for a limited view of the same type (and such a limited 
view is known to exist).</span>&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p5">5</a></div>
<div class="Normal">The result type of a membership test is the predefined 
type Boolean.</div>
<div class="paranum"><a name="p6">6</a></div>
<div class="Normal" style="margin-bottom: 0.4em">The equality operators 
are predefined for every specific type <I>T</I> that is not limited, 
and not an anonymous access type, with the following specifications: 
</div>
<div class="paranum"><a name="p7">7</a></div>
<div class="Examples"><B>function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;/=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean</div>
<div class="paranum"><a name="p7.1">7.1/2</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
The following additional equality operators for the <I>universal_access</I> 
type are declared in package Standard for use with anonymous access types: 
</div>
<div class="paranum"><a name="p7.2">7.2/2</a></div>
<div class="Examples"><B>function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<I>universal_access</I>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;/=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<I>universal_access</I>)&nbsp;<B>return</B>&nbsp;Boolean</div>
<div class="paranum"><a name="p8">8</a></div>
<div class="Normal" style="margin-bottom: 0.4em">The ordering operators 
are predefined for every specific scalar type <I>T</I>, and for every 
discrete array type <I>T</I>, with the following specifications:&nbsp;</div>
<div class="paranum"><a name="p9">9</a></div>
<div class="Examples"><B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&lt;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&gt;&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&gt;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean</div>

<H4 Class="centered">Name Resolution Rules</H4>
<div class="paranum"><a name="p9.1">9.1/2</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00420.TXT">AI95-00420-01</A></I>} 
At least one of the operands of an equality operator for <I>universal_access</I> 
shall be of a specific anonymous access type. Unless the predefined equality 
operator is identified using an expanded name with <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
denoting the package Standard, neither operand shall be of an access-to-object 
type whose designated type is <I>D</I> or <I>D</I>'Class, where <I>D</I> 
has a user-defined primitive equality operator such that:&nbsp;</div>
<div class="paranum"><a name="p9.2">9.2/2</a></div>
<div class="Bulleted">its result type is Boolean;</div>
<div class="paranum"><a name="p9.3">9.3/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0020-1.TXT">AI05-0020-1</A></I>} 
it is declared immediately within the same declaration list as <I>D</I> 
or any partial or incomplete view of <I>D</I>; and</div>
<div class="paranum"><a name="p9.4">9.4/2</a></div>
<div class="Bulleted">at least one of its operands is an access parameter 
with designated type <I>D</I>.&nbsp;</div>
<div class="paranum"><a name="p9.a">9.a/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>The first sentence prevents compatibility 
problems by ensuring that these operators are not used for named access 
types. Also, universal access types do not count for the purposes of 
this rule. Otherwise, equality expressions like (X = <B>null</B>) would 
be ambiguous for normal access types.</div>
<div class="paranum"><a name="p9.b">9.b/2</a></div>
<div class="Annotations">The rest of the rule makes it possible to call 
(including a dispatching call) user-defined &quot;=&quot; operators for 
anonymous access-to-object types (they'd be hidden otherwise), and to 
write user-defined &quot;=&quot; operations for anonymous access types 
(by making it possible to see the universal operator using the Standard 
prefix).&nbsp;</div>
<div class="paranum"><a name="p9.c">9.c/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>We don't need a similar 
rule for anonymous access-to-subprogram types because they can't be primitive 
for any type. Note that any nonprimitive user-defined equality operators 
still are hidden by the universal operators; they'll have to be called 
with a package prefix, but they are likely to be very uncommon.&nbsp;</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p9.5">9.5/2</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
At least one of the operands of the equality operators for <I>universal_access</I> 
shall be of type <I>universal_access</I>, or both shall be of access-to-object 
types, or both shall be of access-to-subprogram types. Further:&nbsp;</div>
<div class="paranum"><a name="p9.6">9.6/2</a></div>
<div class="Bulleted">When both are of access-to-object types, the designated 
types shall be the same or one shall cover the other, and if the designated 
types are elementary or array types, then the designated subtypes shall 
statically match;</div>
<div class="paranum"><a name="p9.7">9.7/2</a></div>
<div class="Bulleted">When both are of access-to-subprogram types, the 
designated profiles shall be subtype conformant.&nbsp;</div>
<div class="paranum"><a name="p9.d">9.d/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>We don't want to allow completely 
arbitrary comparisons, as we don't want to insist that all access types 
are represented in ways that are convertible to one another. For instance, 
a compiler could use completely separate address spaces or incompatible 
representations. Instead, we allow compares if there exists an access 
parameter to which both operands could be converted. Since the user could 
write such an subprogram, and any reasonable meaning for &quot;=&quot; 
would allow using it in such a subprogram, this doesn't impose any further 
restrictions on Ada implementations.&nbsp;</div>
<div class="paranum"><a name="p9.8">9.8/5</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0101-1.TXT">AI12-0101-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0352-1.TXT">AI12-0352-1</A></I>} 
If the profile of an explicitly declared primitive equality operator 
of an untagged record type is type conformant with that of the corresponding 
predefined equality operator, the declaration shall occur before the 
type is frozen.<span class="delete4">&nbsp;In addition, if the untagged record 
type has a nonlimited partial view, then the declaration shall occur 
in the visible part of the enclosing package.</span><span class="insert5">&nbsp;In addition, no type shall have been derived from the untagged record 
type before the declaration of the primitive equality operator.</span> 
<A NAME="I3323"></A>In addition to the places where Legality Rules normally 
apply (see <A HREF="AA-12-3.html">12.3</A>), this rule applies also in 
the private part of an instance of a generic unit.&nbsp;</div>

<H4 Class="centered">Dynamic Semantics</H4>
<div class="paranum"><a name="p10">10</a></div>
<div class="Normal">For discrete types, the predefined relational operators 
are defined in terms of corresponding mathematical operations on the 
position numbers of the values of the operands.</div>
<div class="paranum"><a name="p11">11</a></div>
<div class="Normal">For real types, the predefined relational operators 
are defined in terms of the corresponding mathematical operations on 
the values of the operands, subject to the accuracy of the type.&nbsp;</div>
<div class="paranum"><a name="p11.a">11.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>For floating point types, 
the results of comparing <I>nearly</I> equal values depends on the accuracy 
of the implementation (see <A HREF="AA-G-2-1.html">G.2.1</A>, &ldquo;<A HREF="AA-G-2-1.html">Model 
of Floating Point Arithmetic</A>&rdquo; for implementations that support 
the Numerics Annex).&nbsp;</div>
<div class="paranum"><a name="p11.b">11.b</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>On a machine with 
signed zeros, if the generated code generates both plus zero and minus 
zero, plus and minus zero must be equal by the predefined equality operators. 
</div>
<div class="paranum"><a name="p12">12</a></div>
<div class="Normal">Two access-to-object values are equal if they designate 
the same object, or if both are equal to the null value of the access 
type.</div>
<div class="paranum"><a name="p13">13</a></div>
<div class="Normal">Two access-to-subprogram values are equal if they 
are the result of the same evaluation of an Access <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
or if both are equal to the null value of the access type. Two access-to-subprogram 
values are unequal if they designate different subprograms. <A NAME="I3324"></A>[It 
is unspecified whether two access values that designate the same subprogram 
but are the result of distinct evaluations of Access <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>s 
are equal or unequal.]&nbsp;</div>
<div class="paranum"><a name="p13.a">13.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>This allows each Access <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for a subprogram to designate a distinct &ldquo;wrapper&rdquo; subprogram 
if necessary to support an indirect call.&nbsp;</div>
<div class="paranum"><a name="p14">14/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
<A NAME="I3325"></A>For a type extension, predefined equality is defined 
in terms of the primitive [(possibly user-defined)] equals operator for 
the parent type and for any components that have a record type in the 
extension part, and predefined equality for any other components not 
inherited from the parent type.&nbsp;</div>
<div class="paranum"><a name="p14.a">14.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Two values of a type extension 
are not equal if there is a <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN> 
in the extension part and the two values have different <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0072">variant</A></SPAN>s 
present. This is a ramification of the requirement that a discriminant 
governing such a <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN> 
has to be a &ldquo;new&rdquo; discriminant, and so has to be equal in 
the two values for the values to be equal. Note that <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN>s 
in the parent part need not match if the primitive equals operator for 
the parent type considers them equal.</div>
<div class="paranum"><a name="p14.b">14.b/2</a></div>
<div class="Annotations" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00349.TXT">AI95-00349-01</A></I>} 
The full type extension's operation is used for a private extension. 
This follows as only full types have parent types; the type specified 
in a private extension is an ancestor, but not necessarily the parent 
type. For instance, in:&nbsp;</div>
<div class="paranum"><a name="p14.c">14.c/2</a></div>
<div class="SmallExamples"><B>with</B>&nbsp;Pak1;<BR>
<B>package</B>&nbsp;Pak2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Typ3&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Pak1.Typ1&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Typ3&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Pak1.Typ2&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;Pak2;<BR>
&nbsp;&nbsp;</div>
<div class="paranum"><a name="p14.d">14.d/2</a></div>
<div class="Annotations">the parent type is Pak1.Typ2, not Pak1.Typ1, 
and the equality operator of Pak1.Typ2 is used to create predefined equality 
for Typ3.&nbsp;</div>
<div class="paranum"><a name="p14.1">14.1/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
<span class="delete5">For a derived type whose parent is an untagged 
record type, predefined equality is defined in terms of the primitive 
(possibly user-defined) equals operator of the parent type.</span>&nbsp;</div>
<div class="paranum"><a name="p14.e">14.e/5</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
<span class="delete5">This prevents predefined equality from reemerging 
in generic units for untagged record types. For other uses the primitive 
equality is inherited and the inherited routine is primitive.</span> 
</div>
<div class="paranum"><a name="p15">15/5</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0328-1.TXT">AI12-0328-1</A></I>} 
For a private type, if its full type is a record type<span class="insert5">&nbsp;or a record extension</span>, predefined equality is defined in terms 
of the primitive equals operator of the full type; otherwise, predefined 
equality for the private type is that of its full type.</div>
<div class="paranum"><a name="p16">16</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I3326"></A>For 
other composite types, the predefined equality operators [(and certain 
other predefined operations on composite types &mdash; see <A HREF="AA-4-5-1.html">4.5.1</A> 
and <A HREF="AA-4-6.html">4.6</A>)] are defined in terms of the corresponding 
operation on <I>matching components</I>, defined as follows:&nbsp;</div>
<div class="paranum"><a name="p17">17</a></div>
<div class="Bulleted">For two composite objects or values of the same 
non-array type, matching components are those that correspond to the 
same <SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN>;</div>
<div class="paranum"><a name="p18">18</a></div>
<div class="Bulleted">For two one-dimensional arrays of the same type, 
matching components are those (if any) whose index values match in the 
following sense: the lower bounds of the index ranges are defined to 
match, and the successors of matching indices are defined to match;</div>
<div class="paranum"><a name="p19">19</a></div>
<div class="Bulleted">For two multidimensional arrays of the same type, 
matching components are those whose index values match in successive 
index positions.&nbsp;</div>
<div class="paranum"><a name="p20">20</a></div>
<div class="Normal">The analogous definitions apply if the types of the 
two objects or values are convertible, rather than being the same.&nbsp;</div>
<div class="paranum"><a name="p20.a">20.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>Ada 83 seems to omit this 
part of the definition, though it is used in array type conversions. 
See <A HREF="AA-4-6.html">4.6</A>.&nbsp;</div>
<div class="paranum"><a name="p21">21</a></div>
<div class="Normal" style="margin-bottom: 0.4em">Given the above definition 
of matching components, the result of the predefined equals operator 
for composite types (other than for those composite types covered earlier) 
is defined as follows:&nbsp;</div>
<div class="paranum"><a name="p22">22</a></div>
<div class="Bulleted">If there are no components, the result is defined 
to be True;</div>
<div class="paranum"><a name="p23">23</a></div>
<div class="Bulleted">If there are unmatched components, the result is 
defined to be False;</div>
<div class="paranum"><a name="p24">24/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
Otherwise, the result is defined in terms of the primitive equals operator 
for any matching components that are records, and the predefined equals 
for any other matching components.&nbsp;</div>
<div class="paranum"><a name="p24.a">24.a/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
This asymmetry between components with and without a record type is necessary 
to preserve most upward compatibility and corresponds with the corresponding 
situation with generics, where the predefined operations &ldquo;reemerge&rdquo; 
in a generic for non-record types, but do not for record types. Also, 
only tagged types support user-defined assignment (see <A HREF="AA-7-6.html">7.6</A>), 
so only tagged types can fully handle levels of indirection in the implementation 
of the type. For untagged types, one reason for a user-defined equals 
operator might be to allow values with different bounds or discriminants 
to compare equal in certain cases. When such values are matching components, 
the bounds or discriminants will necessarily match anyway if the discriminants 
of the enclosing values match.&nbsp;</div>
<div class="paranum"><a name="p24.b">24.b</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Two null arrays of the 
same type are always equal; two null records of the same type are always 
equal.</div>
<div class="paranum"><a name="p24.c">24.c/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
Note that if a composite object has a component of a floating point type, 
and the floating point type has both a plus and minus zero, which are 
considered equal by the predefined equality, then a block compare cannot 
be used for the predefined composite equality. Of course, with user-defined 
equals operators for components that are records, a block compare breaks 
down anyway, so this is not the only special case that requires component-by-component 
comparisons. On a one's complement machine, a similar situation might 
occur for integer types, since one's complement machines typically have 
both a plus and minus (integer) zero.&nbsp;</div>
<div class="paranum"><a name="p24.d">24.d/2</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
For a component with an anonymous access type, &ldquo;predefined equality&rdquo; 
is that defined for the <I>universal_access</I> type (anonymous access 
types have no equality operators of their own).</div>
<div class="paranum"><a name="p24.e">24.e/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
For a component with a record type <I>T</I>, &ldquo;the primitive equals 
operator&rdquo; is the one with two parameters of <I>T</I> which returns 
Boolean. We're not talking about some random other primitive function 
named &quot;=&quot;.&nbsp;</div>
<div class="paranum"><a name="p24.1">24.1/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
If the primitive equals operator for an untagged record type is abstract, 
then Program_Error is raised at the point of any <span class="delete5">(implicit) 
</span>call to that abstract subprogram<span class="insert5">[, implicitly 
as part of an equality operation on an enclosing composite object, or 
in an instance of a generic with a formal private type where the actual 
type is a record type with an abstract &quot;=&quot;]</span>.&nbsp;</div>
<div class="paranum"><a name="p24.f">24.f/5</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
An explicit call to an abstract subprogram is <span class="insert5">generally 
</span>illegal. This rule is needed in order to define the effect of 
<span class="insert5">a call in an instance of a generic body, or&nbsp;</span>an 
implicit call such as a call that is part of the predefined equality 
operation for an enclosing composite type that has a component of an 
untagged record type that has an abstract primitive equals operator. 
For tagged types, an abstract primitive equals operator is only allowed 
for an abstract type, and abstract types cannot be components, so this 
case does not occur.&nbsp;</div>
<div class="paranum"><a name="p24.2">24.2/1</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0016">8652/0016</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00123.TXT">AI95-00123-01</A></I>} 
For any composite type, the order in which &quot;=&quot; is called for 
components is unspecified. Furthermore, if the result can be determined 
before calling &quot;=&quot; on some components, it is unspecified whether 
&quot;=&quot; is called on those components.<A NAME="I3327"></A></div>
<div class="paranum"><a name="p25">25</a></div>
<div class="Normal">The predefined &quot;/=&quot; operator gives the 
complementary result to the predefined &quot;=&quot; operator.&nbsp;</div>
<div class="paranum"><a name="p25.a">25.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Furthermore, if the user 
defines an &quot;=&quot; operator that returns Boolean, then a &quot;/=&quot; 
operator is implicitly declared in terms of the user-defined &quot;=&quot; 
operator so as to give the complementary result. See <A HREF="AA-6-6.html">6.6</A>. 
</div>
<div class="paranum"><a name="p26">26/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0264-1.TXT">AI05-0264-1</A></I>} 
<A NAME="I3328"></A>For a discrete array type, the predefined ordering 
operators correspond to <I>lexicographic order</I> using the predefined 
order relation of the component type: A null array is lexicographically 
less than any array having at least one component. In the case of nonnull 
arrays, the left operand is lexicographically less than the right operand 
if the first component of the left operand is less than that of the right; 
otherwise, the left operand is lexicographically less than the right 
operand only if their first components are equal and the tail of the 
left operand is lexicographically less than that of the right (the <I>tail</I> 
consists of the remaining components beyond the first and can be null).</div>
<div class="paranum"><a name="p26.1">26.1/3</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0269-1.TXT">AI05-0269-1</A></I>} 
An <I>individual membership test</I> is the membership test of a single 
<SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>.<A NAME="I3329"></A></div>
<div class="paranum"><a name="p27">27/4</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
<A NAME="I3330"></A>For the evaluation of a membership test using <B>in</B> 
whose <SPAN Class="swiss"><A HREF="AA-4-4.html#S0136">membership_choice_list</A></SPAN> 
has a single <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>, 
the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
and the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN> 
are evaluated in an arbitrary order; the result is the result of the 
individual membership test for the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>.<A NAME="I3331"></A></div>
<div class="paranum"><a name="p27.1">27.1/4</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
For the evaluation of a membership test using <B>in</B> whose <SPAN Class="swiss"><A HREF="AA-4-4.html#S0136">membership_choice_list</A></SPAN> 
has more than one <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>, 
the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
of the membership test is evaluated first and the result of the operation 
is equivalent to that of a sequence consisting of an individual membership 
test on each <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN> 
combined with the short-circuit control form <B>or else</B>.</div>
<div class="paranum"><a name="p27.a.1">27.a.1/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
This equivalence includes the evaluation of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>s; 
evaluation stops as soon as an individual choice evaluates to True.&nbsp;</div>
<div class="paranum"><a name="p28">28/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0269-1.TXT">AI05-0269-1</A></I>} 
An individual membership test yields the result True if:&nbsp;</div>
<div class="paranum"><a name="p28.1">28.1/5</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0264-1.TXT">AI05-0264-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0328-1.TXT">AI12-0328-1</A></I>} 
The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN> 
is a <span class="insert4"><I>choice_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0133">&nbsp;choice_expression</A></SPAN></span>, 
and the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is equal to the value of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>. 
If the tested type is a record type or a <span class="insert5">record 
extension, or is&nbsp;</span>limited <span class="insert5">at the point where 
the membership test occurs</span><span class="delete5">&nbsp;type</span>, 
the test uses the primitive equality for the type; otherwise, the test 
uses predefined equality.</div>
<div class="paranum"><a name="p28.a">28.a/5</a></div>
<div class="Annotations"><span class="insert5"><B>Reason:&nbsp;</B>We use 
the predefined equality operator if the membership test occurs where 
the type is nonlimited if the type is not a record type or record extension. 
However, to avoid confusion, cases where a membership test could use 
different equality operators based on the view are illegal.</span>&nbsp;</div>
<div class="paranum"><a name="p28.2">28.2/4</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0153-3.TXT">AI05-0153-3</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN> 
is a <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
and the value of the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
belongs to the given <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN>.</div>
<div class="paranum"><a name="p29">29/4</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0153-3.TXT">AI05-0153-3</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0071-1.TXT">AI12-0071-1</A></I>} 
The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN> 
is a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>, 
the tested type is scalar, the value of the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
belongs to the range of the named subtype, and the <span class="insert4">value 
satisfies the predicates</span><span class="delete4">&nbsp;predicate</span> 
of the named subtype<span class="delete4">&nbsp;evaluates to True</span>.<span class="insert4"><A NAME="I3332"></A></span><span class="delete4"><A NAME="I3333"></A></span> 
</div>
<div class="paranum"><a name="p29.a">29.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0153-3.TXT">AI05-0153-3</A></I>} 
The scalar membership test only does a range check and a predicate check. 
It does not perform any other check, such as whether a value falls in 
a &ldquo;hole&rdquo; of a &ldquo;holey&rdquo; enumeration type. The Pos 
attribute function can be used for that purpose.</div>
<div class="paranum"><a name="p29.b">29.b</a></div>
<div class="Annotations">Even though Standard.Float is an unconstrained 
subtype, the test &ldquo;X in Float&rdquo; will still return False (presuming 
the evaluation of X does not raise Constraint_Error) when X is outside 
Float'Range.&nbsp;</div>
<div class="paranum"><a name="p30">30/4</a></div>
<div class="Bulleted" style="margin-bottom: 0.3em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0153-3.TXT">AI05-0153-3</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0071-1.TXT">AI12-0071-1</A></I>} 
The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN> 
is a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>, 
the tested type is not scalar, the value of the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
satisfies any constraints of the named subtype, the <span class="insert4">value 
satisfies the predicates</span><span class="delete4">&nbsp;predicate</span> 
of the named subtype<span class="delete4">&nbsp;evaluates to True</span>, 
and:&nbsp;</div>
<div class="paranum"><a name="p30.1">30.1/4</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
if the type of the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is class-wide, the value has a tag that identifies a type covered by 
the tested type;&nbsp;</div>
<div class="paranum"><a name="p30.a">30.a/4</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
Note that the tag is not checked if the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is of a specific type.&nbsp;</div>
<div class="paranum"><a name="p30.2">30.2/4</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0149-1.TXT">AI05-0149-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
if the tested type is an access type and the named subtype excludes null, 
the value of the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is not null;</div>
<div class="paranum"><a name="p30.3">30.3/4</a></div>
<div class="Indented2NestedBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0149-1.TXT">AI05-0149-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
if the tested type is a general access-to-object type, the type of the 
<span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is convertible to the tested type and its accessibility level is no deeper 
than that of the tested type; further, if the designated type of the 
tested type is tagged and the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is nonnull, the tag of the object designated by the value of the <span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
is covered by the designated type of the tested type.&nbsp;</div>
<div class="paranum"><a name="p30.b">30.b/5</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><span class="insert5"><B>To 
be honest:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
<span class="insert5">In some of these cases, the bulleted checks need 
to pass before any predicate check is executed. Otherwise, a predicate 
check could be performed on an object of the wrong type. Consider:</span></div>
<div class="paranum"><a name="p30.c">30.c/5</a></div>
<div class="SmallExamples"><span class="insert5"><B>type</B>&nbsp;Root&nbsp;<B>is&nbsp;tagged&nbsp;null&nbsp;record</B>;<BR>
<B>type</B>&nbsp;Ext&nbsp;<B>is&nbsp;new</B>&nbsp;Root&nbsp;<B>with&nbsp;record</B>&nbsp;Data&nbsp;:&nbsp;Integer;&nbsp;<B>end&nbsp;record</B>;<BR>
<B>function</B>&nbsp;Is_Even&nbsp;(Param&nbsp;:&nbsp;Ext)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;(Param.Data&nbsp;<B>mod</B>&nbsp;2&nbsp;=&nbsp;0);<BR>
<B>subtype</B>&nbsp;Even_Ext&nbsp;<B>is</B>&nbsp;Ext<BR>
&nbsp;&nbsp;<B>with</B>&nbsp;Dynamic_Predicate&nbsp;=&gt;&nbsp;Is_Even&nbsp;(Even_Ext);<BR>
<B>function</B>&nbsp;F&nbsp;(X&nbsp;:&nbsp;Root'Class)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;(X&nbsp;<B>in</B>&nbsp;Even_Ext);<BR>
Flag&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;F&nbsp;(Root'(<B>null&nbsp;record</B>));</span></div>
<div class="paranum"><a name="p30.d">30.d/5</a></div>
<div class="Annotations"><span class="insert5">If the predicate check 
is performed before the tag check or regardless of the result of that 
check, Is_Even would be called on an object that does not have a Data 
component. Similar cases can be constructed for general access types.</span> 
</div>
<div class="paranum"><a name="p31">31/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0264-1.TXT">AI05-0264-1</A></I>} 
Otherwise, the test yields the result False.</div>
<div class="paranum"><a name="p32">32</a></div>
<div class="Normal">A membership test using <B>not in</B> gives the complementary 
result to the corresponding membership test using <B>in</B>.</div>
<div class="paranum"><a name="p32.a">32.a/4</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
<TT><I>X</I> <B>not in</B> <I>A</I> | <I>B</I> | <I>C</I></TT> is intended 
to be exactly equivalent to <TT><B>not</B> (<I>X</I> <B>in</B> <I>A</I> 
| <I>B</I> | <I>C</I>)</TT>, including the order of evaluation of the 
<span class="insert4"><I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN></span><span class="delete4"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">&nbsp;simple_expression</A></SPAN></span> 
and <SPAN Class="swiss"><A HREF="AA-4-4.html#S0137">membership_choice</A></SPAN>s. 
</div>

<H4 Class="centered">Implementation Requirements</H4>
<div class="paranum"><a name="p32.1">32.1/1</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0016">8652/0016</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00123.TXT">AI95-00123-01</A></I>} 
For all nonlimited types declared in language-defined packages, the &quot;=&quot; 
and &quot;/=&quot; operators of the type shall behave as if they were 
the predefined equality operators for the purposes of the equality of 
composite types and generic formal types.&nbsp;</div>
<div class="paranum"><a name="p32.a.1">32.a.1/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00123.TXT">AI95-00123-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
If any language-defined types are implemented with a user-defined &quot;=&quot; 
operator, then either the full type must be a record type, or the compiler 
must use &ldquo;magic&rdquo; to implement equality for this type. A normal 
user-defined &quot;=&quot; operator for a non-record type does <I>not</I> 
meet this requirement.&nbsp;</div>
<div class="paranum"><a name="p33">33/2</a></div>
<div class="Notes"><SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
</div>
<div class="paranum"><a name="p34">34</a></div>
<div class="Notes">NOTE&nbsp;&nbsp;&nbsp;If a composite type has components 
that depend on discriminants, two values of this type have matching components 
if and only if their discriminants are equal. Two nonnull arrays have 
matching components if and only if the length of each dimension is the 
same for both.&nbsp;</div>

<H4 Class="centered">Examples</H4>
<div class="paranum"><a name="p35">35</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><I>Examples of expressions 
involving relational operators and membership tests:</I>&nbsp;</div>
<div class="paranum"><a name="p36">36</a></div>
<div class="Examples">X&nbsp;/=&nbsp;Y</div>
<div class="paranum"><a name="p37">37/5</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0178-1.TXT">AI12-0178-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0425-1.TXT">AI12-0425-1</A></I>} 
<span class="insert5">A_String&nbsp;=&nbsp;&quot;A&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;True&nbsp;(see&nbsp;<A HREF="AA-3-3-1.html">3.3.1</A>)</I></SPAN><BR>
</span>&quot;&quot;&nbsp;&lt;&nbsp;<span class="insert5">A_String</span><span class="delete5">&nbsp;&quot;A&quot;</span>&nbsp;<B>and</B>&nbsp;<span class="insert5">A_String</span><span class="delete5">&nbsp;&quot;A&quot;</span>&nbsp;&lt;&nbsp;&quot;Aa&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;True</I></SPAN><BR>
<span class="insert5">A_String</span><span class="delete5">&nbsp;&quot;A&quot;</span>&nbsp;&lt;&nbsp;<span class="insert5">&quot;Bb&quot;</span><span class="delete5">&nbsp;&quot;B&quot;</span>&nbsp;<B>and</B>&nbsp;<span class="insert5">A_String</span><span class="delete5">&nbsp;&quot;A&quot;</span>&nbsp;&lt;&nbsp;&quot;A&nbsp;&nbsp;&quot;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;True</I></SPAN></div>
<div class="paranum"><a name="p38">38/3</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0264-1.TXT">AI05-0264-1</A></I>} 
My_Car&nbsp;=&nbsp;<B>null</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;True&nbsp;if&nbsp;My_Car&nbsp;has&nbsp;been&nbsp;set&nbsp;to&nbsp;null&nbsp;(see&nbsp;<A HREF="AA-3-10-1.html">3.10.1</A>)</I></SPAN><BR>
My_Car&nbsp;=&nbsp;Your_Car&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;True&nbsp;if&nbsp;we&nbsp;both&nbsp;share&nbsp;the&nbsp;same&nbsp;car</I></SPAN><BR>
My_Car.<B>all</B>&nbsp;=&nbsp;Your_Car.<B>all</B>&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;True&nbsp;if&nbsp;the&nbsp;two&nbsp;cars&nbsp;are&nbsp;identical</I></SPAN></div>
<div class="paranum"><a name="p39">39/3</a></div>
<div class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
N&nbsp;<B>not</B>&nbsp;<B>in</B>&nbsp;1&nbsp;..&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;range&nbsp;membership&nbsp;test</I></SPAN><BR>
Today&nbsp;<B>in</B>&nbsp;Mon&nbsp;..&nbsp;Fri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;range&nbsp;membership&nbsp;test</I></SPAN><BR>
Today&nbsp;<B>in</B>&nbsp;Weekday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;subtype&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="AA-3-5-1.html">3.5.1</A>)</I></SPAN><BR>
Card&nbsp;<B>in</B>&nbsp;Clubs&nbsp;|&nbsp;Spades&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;list&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="AA-3-5-1.html">3.5.1</A>)</I></SPAN><BR>
Archive&nbsp;<B>in</B>&nbsp;Disk_Unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;subtype&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="AA-3-8-1.html">3.8.1</A>)</I></SPAN><BR>
Tree.<B>all</B>&nbsp;<B>in</B>&nbsp;Addition'Class&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;class&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="AA-3-9-1.html">3.9.1</A>)</I></SPAN></div>

<H4 Class="centered">Extensions to Ada 83</H4>
<div class="paranum"><a name="p39.a">39.a</a></div>
<div class="Annotations"><A NAME="I3334"></A>Membership tests can be 
used to test the tag of a class-wide value.</div>
<div class="paranum"><a name="p39.b">39.b</a></div>
<div class="Annotations">Predefined equality for a composite type is 
defined in terms of the primitive equals operator for tagged components 
or the parent part.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<div class="paranum"><a name="p39.c">39.c</a></div>
<div class="Annotations">The term &ldquo;membership test&rdquo; refers 
to the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0135">relation</A></SPAN> 
&quot;X in S&quot; rather to simply the reserved word <B>in</B> or <B>not 
in</B>.</div>
<div class="paranum"><a name="p39.d">39.d</a></div>
<div class="Annotations">We use the term &ldquo;equality operator&rdquo; 
to refer to both the = (equals) and /= (not equals) operators. Ada 83 
referred to = as <I>the</I> equality operator, and /= as the inequality 
operator. The new wording is more consistent with the ISO 10646 name 
for &quot;=&quot; (equals sign) and provides a category similar to &ldquo;ordering 
operator&rdquo; to refer to both = and /=.</div>
<div class="paranum"><a name="p39.e">39.e</a></div>
<div class="Annotations">We have changed the term &ldquo;catenate&rdquo; 
to &ldquo;concatenate&rdquo;.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 95</H4>
<div class="paranum"><a name="p39.f">39.f/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00420.TXT">AI95-00420-01</A></I>} 
<A NAME="I3335"></A>The <I>universal_access</I> equality operators are 
new. They provide equality operations (most importantly, testing against 
<B>null</B>) for anonymous access types.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum"><a name="p39.g">39.g/2</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0016">8652/0016</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00123.TXT">AI95-00123-01</A></I>} 
<B>Corrigendum:</B> Wording was added to clarify that the order of calls 
(and whether the calls are made at all) on &quot;=&quot; for components 
is unspecified. Also clarified that &quot;=&quot; must compose properly 
for language-defined types.</div>
<div class="paranum"><a name="p39.h">39.h/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
Memberships were adjusted to allow interfaces which don't cover the tested 
type, in order to be consistent with type conversions.&nbsp;</div>

<H4 Class="centered">Inconsistencies With Ada 2005</H4>
<div class="paranum"><a name="p39.i">39.i/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
<A NAME="I3336"></A>User-defined untagged record equality is now defined 
to compose and be used in generics. Any code which assumes that the predefined 
equality reemerges in generics and in predefined equals for composite 
types could fail. However, it is much more likely that this change will 
fix bugs, as the behavior that would be expected (the user-defined &quot;=&quot; 
is used) will be true in more cases.</div>
<div class="paranum"><a name="p39.j">39.j/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
If a composite type contains a component of an untagged record type with 
an abstract equality operation, calling &quot;=&quot; on the composite 
type will raise Program_Error, while in the past a result will be returned 
using the predefined equality. This is quite possible in ASIS programs; 
it will detect a bug in such programs but of course the programs will 
need to be fixed before they will work.&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 2005</H4>
<div class="paranum"><a name="p39.k">39.k/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0123-1.TXT">AI05-0123-1</A></I>} 
<A NAME="I3337"></A>Late and hidden overriding of equality for untagged 
record types is now prohibited. This is necessary to make composition 
of equality predictable. It should always be possible to move the overriding 
to an earlier spot where it will be legal.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 2005</H4>
<div class="paranum"><a name="p39.l">39.l/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0149-1.TXT">AI05-0149-1</A></I>} 
<A NAME="I3338"></A>Membership tests for valid accessibility levels and 
tag coverage by the designated type for general access types are new.</div>
<div class="paranum"><a name="p39.m">39.m/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0153-3.TXT">AI05-0153-3</A></I>} 
Membership tests now include a predicate check.</div>
<div class="paranum"><a name="p39.n">39.n/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0158-1.TXT">AI05-0158-1</A></I>} 
Membership tests now allow multiple choices.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2005</H4>
<div class="paranum"><a name="p39.o">39.o/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0020-1.TXT">AI05-0020-1</A></I>} 
<B>Correction:</B> Wording was added to clarify that <I>universal_access</I> 
&quot;=&quot; does not apply if an appropriate operator is declared for 
a partial or incomplete view of the designated type. Otherwise, adding 
a partial or incomplete view could make some &quot;=&quot; operators 
ambiguous.&nbsp;</div>

<H4 Class="centered">Inconsistencies With Ada 2012</H4>
<div class="paranum"><a name="p39.p">39.p/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0101-1.TXT">AI12-0101-1</A></I>} 
<span class="insert4"><A NAME="I3339"></A><B>Corrigendum:</B> Removed 
the incompatible rule preventing the declaration of &quot;=&quot; in 
the private part of a package specification for an untagged record type 
that completes a private type. Any code that calls the predefined &quot;=&quot; 
on the private type will now execute the body for the redefined &quot;=&quot; 
instead for the predefined &quot;=&quot;. Eliminating the rule eliminates 
an unnecessary incompatibility (especially for programs that never call 
the predefined &quot;=&quot;). Moreover, (like the composition of untagged 
record &quot;=&quot; in Ada 2012) this is more likely to fix bugs than 
cause them (who defines an &quot;=&quot; with a presumably different 
result and does not want clients to use it?).</span>&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 2012</H4>
<div class="paranum"><a name="p39.q">39.q/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0328-1.TXT">AI12-0328-1</A></I>} 
<span class="insert5"><A NAME="I3340"></A>A membership test is now illegal 
if all of the following are True:</span>&nbsp;</div>
<div class="paranum"><a name="p39.r">39.r/5</a></div>
<div class="SmallBulleted"><span class="insert5">The membership test 
has one or more <I>choice_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN>s;</span></div>
<div class="paranum"><a name="p39.s">39.s/5</a></div>
<div class="SmallBulleted"><span class="insert5">The membership test 
occurs in a place where the tested type is nonlimited;</span></div>
<div class="paranum"><a name="p39.t">39.t/5</a></div>
<div class="SmallBulleted"><span class="insert5">The tested type has 
a limited view with a primitive &quot;=&quot; operator;</span></div>
<div class="paranum"><a name="p39.u">39.u/5</a></div>
<div class="SmallBulleted"><span class="insert5">The full type of the 
tested type is not a record type or a record extension.</span>&nbsp;</div>
<div class="paranum"><a name="p39.v">39.v/5</a></div>
<div class="Annotations"><span class="insert5">In such a case, the limited 
and nonlimited views would use different equality operators, which would 
be confusing and would cause various semantic difficulties. We believe 
such cases to be quite rare, especially as such membership tests are 
new to Ada 2012. The workaround is to replace such memberships with equality 
tests (assuming that the primitive &quot;=&quot; is intended; the predefined 
&quot;=&quot; is hidden in such cases and an extra type is needed to 
make it accessible).</span>&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2012</H4>
<div class="paranum"><a name="p39.w">39.w/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0039-1.TXT">AI12-0039-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Reworded membership tests to 
use the syntax items <I>tested_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN> 
and <I>choice_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN>. 
This was necessary to eliminate wording ambiguities introduced when the 
grammar was corrected to eliminate syntax ambiguities. (Both of the above 
are now <SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN>s, 
so merely talking about a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0138">simple_expression</A></SPAN> 
is insufficient.)</span></div>
<div class="paranum"><a name="p39.x">39.x/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0071-1.TXT">AI12-0071-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Updated wording of the membership 
tests to use the new term &quot;satisfies the predicates&quot; (see <A HREF="AA-3-2-4.html">3.2.4</A>).</span></div>
<div class="paranum"><a name="p39.y">39.y/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0413-1.TXT">AI12-0413-1</A></I>} 
<span class="insert5"><B>Correction:</B> Clarified that a call to an 
abstract equality in an instance body raises Program_Error.</span>&nbsp;</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
