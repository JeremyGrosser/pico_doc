<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Shared Variable Control</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert4 {text-decoration: underline; color: rgb(153,0,0) }
    SPAN.delete4 {text-decoration: line-through; color: rgb(153,0,0) }
    SPAN.insert5 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete5 {text-decoration: line-through; color: rgb(0,102,0) }
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.8em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 4.3em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.8em; margin-bottom: 0.6em}
    DIV.SmallBulleted-NoPrefix {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 9.3em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 9.3em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.WideHanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.8em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.WideHanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.8em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,51,153)"><B>Annotated</B></SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)"><B>&nbsp;Ada Reference Manual</B> (Ada 2022 Draft 35)</SPAN> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-6-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>C.6 Shared Variable Control</H1>
<div class="paranum"><a name="p1">1/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0299-1.TXT">AI05-0299-1</A></I>} 
[This subclause defines representation aspects that control the use of 
shared variables.]&nbsp;</div>
<div class="Normal"><SPAN STYLE="font-size: 80%"><I>Paragraphs 2 through 
6 were moved to <A HREF="AA-J.html">Annex J</A>, &ldquo;<A HREF="AA-J.html">Obsolescent 
Features</A>&rdquo;.</I></SPAN>&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p6.1">6.1/5</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0282-1.TXT">AI12-0282-1</A></I>} 
For an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN>, 
<span class="delete5">or&nbsp;</span>a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN>, 
<span class="insert5">or a <SPAN Class="swiss"><A HREF="AA-12-5.html#S0321">formal_complete_type_declaration</A></SPAN>, 
</span>the following representation aspects may be specified:</div>
<div class="paranum"><a name="p6.2">6.2/3</a></div>
<div class="WideHanging-Term">&nbsp;Atomic</div><div class="WideHanging-Body">
The type of aspect Atomic is Boolean.<A NAME="I9589"></A><A NAME="I9590"></A></div>
<div class="paranum"><a name="p6.a">6.a/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Atomic:&nbsp;</B>Declare 
that a type, object, or component is atomic.</div>
<div class="paranum"><a name="p6.3">6.3/3</a></div>
<div class="WideHanging-Term">&nbsp;Independent</div><div class="WideHanging-Body">
The type of aspect Independent is Boolean.<A NAME="I9591"></A><A NAME="I9592"></A></div>
<div class="paranum"><a name="p6.b">6.b/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Independent: 
</B>Declare that a type, object, or component is independently addressable.</div>
<div class="paranum"><a name="p6.4">6.4/3</a></div>
<div class="WideHanging-Term">&nbsp;Volatile</div><div class="WideHanging-Body">
The type of aspect Volatile is Boolean.<A NAME="I9593"></A><A NAME="I9594"></A></div>
<div class="paranum"><a name="p6.c">6.c/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Volatile:&nbsp;</B>Declare 
that a type, object, or component is volatile.</div>
<div class="paranum"><a name="p6.5">6.5/5</a></div>
<div class="WideHanging-Term">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">Full_Access_Only</span></div><div class="WideHanging-Body"><br clear="left">
<span class="insert5">The type of aspect Full_Access_Only is Boolean.<A NAME="I9595"></A><A NAME="I9596"></A></span></div>
<div class="paranum"><a name="p6.c.1">6.c.1/5</a></div>
<div class="Annotations"><span class="insert5"><B>Aspect Description 
for&nbsp;</B></span><span class="insert5"><B>Full_Access_Only:&nbsp;</B></span><span class="insert5">Declare 
that a volatile type, object, or component is full access.</span></div>
<div class="paranum"><a name="p6.6">6.6/5</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0282-1.TXT">AI12-0282-1</A></I>} 
For a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
of an array type<span class="insert5">,</span><span class="delete5">&nbsp;(including the anonymous type of</span> an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
<span class="insert5">for an object of an anonymous array type, or the 
<SPAN Class="swiss"><A HREF="AA-12-5.html#S0321">formal_complete_type_declaration</A></SPAN> 
of a formal array type</span><span class="delete5">&nbsp;of an anonymous array 
object)</span>, the following representation aspects may be specified:</div>
<div class="paranum"><a name="p6.7">6.7/3</a></div>
<div class="WideHanging-Term">&nbsp;Atomic_Components</div><div class="WideHanging-Body"><br clear="left">
The type of aspect Atomic_Components is Boolean.<A NAME="I9597"></A><A NAME="I9598"></A></div>
<div class="paranum"><a name="p6.d">6.d/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Atomic_Components: 
</B>Declare that the components of an array type or object are atomic.</div>
<div class="paranum"><a name="p6.8">6.8/3</a></div>
<div class="WideHanging-Term">&nbsp;Volatile_Components</div><div class="WideHanging-Body"><br clear="left">
The type of aspect Volatile_Components is Boolean.<A NAME="I9599"></A><A NAME="I9600"></A></div>
<div class="paranum"><a name="p6.e">6.e/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Volatile_Components: 
</B>Declare that the components of an array type or object are volatile.</div>
<div class="paranum"><a name="p6.9">6.9/5</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0282-1.TXT">AI12-0282-1</A></I>} 
For a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
<span class="insert5">of a composite type,</span><span class="delete5">&nbsp;(including the anonymous type of</span> an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
<span class="insert5">for an object of an anonymous composite type, or 
the <SPAN Class="swiss"><A HREF="AA-12-5.html#S0321">formal_complete_type_declaration</A></SPAN> 
of a formal composite type</span><span class="delete5">&nbsp;of an anonymous 
array object)</span>, the following representation aspect may be specified:</div>
<div class="paranum"><a name="p6.10">6.10/3</a></div>
<div class="WideHanging-Term">&nbsp;&nbsp;Independent_Components</div><div class="WideHanging-Body"><br clear="left">
The type of aspect Independent_Components is Boolean.<A NAME="I9601"></A><A NAME="I9602"></A></div>
<div class="paranum"><a name="p6.f">6.f/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Independent_Components: 
</B>Declare that the components of an array or record type, or an array 
object, are independently addressable.</div>
<div class="paranum"><a name="p6.11">6.11/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
If any of these aspects are directly specified, the <SPAN Class="swiss"><A HREF="AA-13-1-1.html#S0348">aspect_definition</A></SPAN> 
shall be a static expression. If not specified <span class="insert5">for 
a type&nbsp;</span>(including by inheritance), <span class="insert5">the Atomic, 
Atomic_Components, and Full_Access_Only</span><span class="delete5">&nbsp;each 
of these</span> aspects <span class="insert5">are</span><span class="delete5">&nbsp;is</span> 
False.<span class="insert5">&nbsp;If any of these aspects are specified True 
for a type, then the corresponding aspect is True for all objects of 
the type. If the Atomic aspect is specified True, then the aspects Volatile, 
Independent, and Volatile_Component (if defined) are True; if the Atomic_Components 
aspect is specified True, then the aspects Volatile, Volatile_Components, 
and Independent_Components are True. If the Volatile aspect is specified 
True, then the Volatile_Components aspect (if defined) is True, and vice 
versa. When not determined by one of the other aspects, or for an object 
by its type, the Volatile, Volatile_Components, Independent, and Independent_Components 
aspects are False.</span></div>
<div class="paranum"><a name="p6.g">6.g/5</a></div>
<div class="Annotations"><span class="insert5"><B>Ramification:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">Aspects Volatile and Volatile_Components (when 
defined) are equivalent. We provide the Volatile_Components aspect only 
to give symmetry with Atomic_Components and Independent_Components aspects.</span> 
</div>
<div class="paranum"><a name="p7">7/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00272.TXT">AI95-00272-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
<A NAME="I9603"></A>An <I>atomic</I> type is one for which the aspect 
Atomic is True. An <I>atomic</I> object (including a component) is one 
for which the aspect Atomic is True, or a component of an array for which 
the aspect Atomic_Components is True for the associated type, or any 
object of an atomic type, other than objects obtained by evaluating a 
slice.&nbsp;</div>
<div class="paranum"><a name="p7.a">7.a/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00272.TXT">AI95-00272-01</A></I>} 
A slice of an atomic array object is not itself atomic. That's necessary 
as executing a read or write of a dynamic number of components in a single 
instruction is not possible on many targets.&nbsp;</div>
<div class="paranum"><a name="p8">8/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
<A NAME="I9604"></A>A <I>volatile</I> type is one for which the aspect 
Volatile is True. A <I>volatile</I> object (including a component) is 
one for which the aspect Volatile is True, or a component of an array 
for which the aspect Volatile_Components is True for the associated type, 
or any object of a volatile type. In addition, every atomic type or object 
is also defined to be volatile. Finally, if an object is volatile, then 
so are all of its subcomponents [(the same does not apply to atomic)].</div>
<div class="paranum"><a name="p8.1">8.1/4</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0009-1.TXT">AI05-0009-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0001-1.TXT">AI12-0001-1</A></I>} 
When True, the aspects Independent and Independent_Components <I>specify 
as independently addressable</I> the named object or component(s), or 
in the case of a type, all objects or components of that type. All atomic 
objects <span class="insert4">and aliased objects&nbsp;</span>are considered 
to be specified as independently addressable.<A NAME="I9605"></A><A NAME="I9606"></A></div>
<div class="paranum"><a name="p8.a">8.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>If the compiler cannot 
guarantee that an object (including a component) for which aspect Independent 
or aspect Independent_Components is True is independently addressable 
from any other nonoverlapping object, then the aspect specification must 
be rejected.</div>
<div class="paranum"><a name="p8.b">8.b/3</a></div>
<div class="Annotations">Similarly, an atomic object (including atomic 
components) is always independently addressable from any other nonoverlapping 
object. Any representation item which would prevent this from being true 
should be rejected, notwithstanding what this Standard says elsewhere 
(specifically, in the Recommended Level of Support).&nbsp;</div>
<div class="paranum"><a name="p8.2">8.2/5</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">The Full_Access_Only aspect shall not be specified 
unless the associated type or object is volatile [(or atomic)]. A <I>full 
access</I> type is any atomic type, or a volatile type for which the 
aspect Full_Access_Only is True.<A NAME="I9607"></A> A <I>full access</I> 
object (including a component) is any atomic object, or a volatile object 
for which the aspect Full_Access_Only is True for the object[ or its 
type].<A NAME="I9608"></A> A Full_Access_Only aspect is illegal if any 
subcomponent of the object or type is a full access object or is of a 
generic formal type.</span></div>
<div class="paranum"><a name="p8.c">8.c/5</a></div>
<div class="Annotations"><span class="insert5"><B>Ramification:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">This last rule breaks privacy, but that is considered 
OK for representation clauses when there is no clear alternative. Note 
that atomic objects may be nested, so long as the outer atomic object 
does not have the Full_Access_Only aspect True.</span>&nbsp;</div>
<div class="paranum"><a name="p8.d">8.d/5</a></div>
<div class="Annotations"><span class="insert5"><B>Reason:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">We disallow subcomponents of a generic formal type 
in a Full_Access_Only object or type as the actual to a formal type can 
be a full access type. We could have had a less restrictive rule, but 
such a use is unlikely as full access only objects are intended to be 
used to access memory-mapped devices with access restrictions, and those 
will need a concrete mapping not possible for generic formal types.</span> 
</div>
<div class="Normal"><SPAN STYLE="font-size: 80%"><I>Paragraph 9 was moved 
to <A HREF="AA-J.html">Annex J</A>, &ldquo;<A HREF="AA-J.html">Obsolescent 
Features</A>&rdquo;.</I></SPAN>&nbsp;</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p9.1">9.1/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
If aspect Independent_Components is specified for a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN>, 
the declaration shall be that of an array or record type.</div>
<div class="paranum"><a name="p10">10/4</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0001-1.TXT">AI12-0001-1</A></I>} 
<A NAME="I9609"></A>It is illegal to specify either of the aspects Atomic 
or Atomic_Components to have the value True for an object or type if 
the implementation cannot support the indivisible <span class="insert4">and 
independent&nbsp;</span>reads and updates required by the aspect (see below).</div>
<div class="paranum"><a name="p11">11/4</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0001-1.TXT">AI12-0001-1</A></I>} 
It is illegal to specify the Size attribute of an atomic object, the 
Component_Size attribute for an array type with atomic components, or 
the layout attributes of an atomic component, in a way that prevents 
the implementation from performing the required indivisible <span class="insert4">and 
independent&nbsp;</span>reads and updates.</div>
<div class="paranum"><a name="p12">12/5</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0142-4.TXT">AI05-0142-4</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0218-1.TXT">AI05-0218-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0282-1.TXT">AI12-0282-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
If an atomic object is passed as a parameter, then the formal parameter 
shall either have an atomic type or allow pass by copy. If an atomic 
object is used as an actual for a generic formal object of mode <B>in 
out</B>, then the type of the generic formal object shall be atomic. 
If the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for an Access attribute denotes an atomic object [(including a component)], 
then the designated type of the resulting access type shall be atomic.<span class="delete5">&nbsp;If an atomic type is used as an actual for a generic formal derived type, 
then the ancestor of the formal type shall be atomic.</span> Corresponding 
rules apply to volatile objects and <span class="insert5">to full access 
objects</span><span class="delete5">&nbsp;types</span>.</div>
<div class="paranum"><a name="p12.a">12.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0142-4.TXT">AI05-0142-4</A></I>} 
A formal parameter allows pass by copy if it is not <B>aliased</B> and 
it is of a type that allows pass by copy (that is, is not a by-reference 
type).&nbsp;</div>
<div class="paranum"><a name="p12.1">12.1/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">If a nonatomic subcomponent of a full access object 
is passed as an actual parameter in a call then the formal parameter 
shall allow pass by copy (and, at run time, the parameter shall be passed 
by copy). A nonatomic subcomponent of a full access object shall not 
be used as an actual for a generic formal of mode <B>in out</B>. The 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> of 
an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for an Access attribute shall not denote a nonatomic subcomponent of 
a full access object.</span></div>
<div class="paranum"><a name="p12.2">12.2/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0218-1.TXT">AI05-0218-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0282-1.TXT">AI12-0282-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
If <span class="insert5">the Atomic, Atomic_Components, Volatile, Volatile_Components, 
Independent, Independent_Components, or Full_Access_Only aspect is True 
for a generic formal type, then that aspect shall be True for the actual 
type. If an atomic type is used as an actual for a generic formal derived 
type, then the ancestor of the formal type shall be atomic. A corresponding 
rule applies to volatile types and similarly to full access types</span><span class="delete5">&nbsp;a 
volatile type is used as an actual for a generic formal array type, then 
the element type of the formal type shall be volatile</span>.</div>
<div class="paranum"><a name="p12.3">12.3/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">If a type with volatile components is used as an 
actual for a generic formal array type, then the components of the formal 
type shall be volatile. Furthermore, if the actual type has atomic components 
and the formal array type has aliased components, then the components 
of the formal array type shall also be atomic. A corresponding rule applies 
when the actual type has volatile full access components.</span></div>
<div class="paranum"><a name="p12.b">12.b/5</a></div>
<div class="Annotations"><span class="insert5"><B>Reason:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">The limitations on formal array types are separate 
for volatile and atomic because of the fact that only volatility is carried 
down to all subcomponents of a volatile object, while atomicity is not. 
The goal of both limitations is that we don't want 'Access for an access 
type to produce a value that designates an object whose atomicity and 
volatility don't agree with that of the designated type of the access 
type. The above rules ensure that the generic &ldquo;sees&rdquo; the 
relevant volatility and atomicity.</span>&nbsp;</div>
<div class="paranum"><a name="p13">13/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
If an aspect Volatile, Volatile_Components, Atomic, or Atomic_Components 
is directly specified to have the value True for a stand-alone constant 
object, then the aspect Import shall also be specified as True for it. 
</div>
<div class="paranum"><a name="p13.a">13.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Hence, no initialization 
expression is allowed for such a constant. Note that a constant that 
is atomic or volatile because of its type is allowed.&nbsp;</div>
<div class="paranum"><a name="p13.b">13.b</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Stand-alone constants that are 
explicitly specified as Atomic or Volatile only make sense if they are 
being manipulated outside the Ada program. From the Ada perspective the 
object is read-only. Nevertheless, if imported and atomic or volatile, 
the implementation should presume it might be altered externally. For 
an imported stand-alone constant that is not atomic or volatile, the 
implementation can assume that it will not be altered.&nbsp;</div>
<div class="paranum"><a name="p13.c">13.c/3</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0218-1.TXT">AI05-0218-1</A></I>} 
Volatile_Components and Atomic_Components actually are aspects of the 
anonymous array type; this rule only applies when the aspect is specified 
directly on the constant object and not when the (named) array type has 
the aspect.&nbsp;</div>
<div class="paranum"><a name="p13.1">13.1/3</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0009-1.TXT">AI05-0009-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
It is illegal to specify the aspect Independent or Independent_Components 
as True for a component, object or type if the implementation cannot 
provide the independent addressability required by the aspect (see <A HREF="AA-9-10.html">9.10</A>).</div>
<div class="paranum"><a name="p13.2">13.2/3</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0009-1.TXT">AI05-0009-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
It is illegal to specify a representation aspect for a component, object 
or type for which the aspect Independent or Independent_Components is 
True, in a way that prevents the implementation from providing the independent 
addressability required by the aspect.</div>
<div class="Normal"><SPAN STYLE="font-size: 80%"><I>Paragraph 14 was 
moved to <A HREF="AA-J.html">Annex J</A>, &ldquo;<A HREF="AA-J.html">Obsolescent 
Features</A>&rdquo;.</I></SPAN>&nbsp;</div>

<H4 Class="centered">Dynamic Semantics</H4>
<div class="paranum"><a name="p15">15</a></div>
<div class="Normal">For an atomic object (including an atomic component) 
all reads and updates of the object as a whole are indivisible.</div>
<div class="paranum"><a name="p16">16/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0117-1.TXT">AI05-0117-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0275-1.TXT">AI05-0275-1</A></I>} 
All tasks of the program (on all processors) that read or update volatile 
variables see the same order of updates to the variables. A use of an 
atomic variable or other mechanism may be necessary to avoid erroneous 
execution and to ensure that access to nonatomic volatile variables is 
sequential (see <A HREF="AA-9-10.html">9.10</A>).</div>
<div class="paranum"><a name="p16.a">16.a/3</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0117-1.TXT">AI05-0117-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0275-1.TXT">AI05-0275-1</A></I>} 
To ensure this, on a multiprocessor, any read or update of an atomic 
object may require the use of an appropriate memory barrier.&nbsp;</div>
<div class="paranum"><a name="p16.b">16.b/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0275-1.TXT">AI05-0275-1</A></I>} 
From <A HREF="AA-9-10.html">9.10</A> it follows that (in non-erroneous 
programs) accesses to variables, including those shared by multiple tasks, 
are always sequential. This guarantees that no task will ever see partial 
updates of any variable. For volatile variables (including atomic variables), 
the above rule additionally specifies that all tasks see the same order 
of updates.</div>
<div class="paranum"><a name="p16.c">16.c/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0275-1.TXT">AI05-0275-1</A></I>} 
If for a shared variable <I>X</I>, a read of <I>X</I> occurs sequentially 
after an update of <I>X</I>, then the read will return the updated value 
if <I>X</I> is volatile or atomic, but may or or may not return the updated 
value if <I>X</I> is nonvolatile. For nonvolatile accesses, a signaling 
action is needed in order to share the updated value.</div>
<div class="paranum"><a name="p16.d">16.d/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0275-1.TXT">AI05-0275-1</A></I>} 
Because accesses to the same atomic variable by different tasks establish 
a sequential order between the actions of those tasks, implementations 
may be required to emit memory barriers around such updates or use atomic 
instructions that imply such barriers.&nbsp;</div>
<div class="paranum"><a name="p17">17</a></div>
<div class="Normal"><A NAME="I9610"></A>Two actions are sequential (see 
<A HREF="AA-9-10.html">9.10</A>) if each is the read or update of the 
same atomic object.</div>
<div class="paranum"><a name="p18">18</a></div>
<div class="Normal"><A NAME="I9611"></A>If a type is atomic or volatile 
and it is not a by-copy type, then the type is defined to be a by-reference 
type. If any subcomponent of a type is atomic or volatile, then the type 
is defined to be a by-reference type.</div>
<div class="paranum"><a name="p19">19</a></div>
<div class="Normal">If an actual parameter is atomic or volatile, and 
the corresponding formal parameter is not, then the parameter is passed 
by copy.&nbsp;</div>
<div class="paranum"><a name="p19.a">19.a</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>Note that in the 
case where such a parameter is normally passed by reference, a copy of 
the actual will have to be produced at the call-site, and a pointer to 
the copy passed to the formal parameter. If the actual is atomic, any 
copying has to use indivisible read on the way in, and indivisible write 
on the way out.&nbsp;</div>
<div class="paranum"><a name="p19.b">19.b</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>It has to be known at compile 
time whether an atomic or a volatile parameter is to be passed by copy 
or by reference. For some types, it is unspecified whether parameters 
are passed by copy or by reference. The above rules further specify the 
parameter passing rules involving atomic and volatile types and objects. 
</div>
<div class="paranum"><a name="p19.1">19.1/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0347-1.TXT">AI12-0347-1</A></I>} 
<span class="insert5">All reads of or writes to any nonatomic subcomponent 
of a full access object are performed by reading and/or writing all of 
the nearest enclosing full access object.</span></div>
<div class="paranum"><a name="p19.c">19.c/5</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0005-1.TXT">AI12-0005-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
} <span class="insert5">For example, if a 32-bit record object has four 
nonatomic components, each occupying one byte, then an assignment to 
one of those components might normally be implemented on some target 
machines via some sort of store_byte instruction; if the record object 
is an atomic full access object then instead a 32-bit read-modify-write 
must be performed. That read-modify-write need not be atomic, although 
the read and the write must each separately be atomic. Note that it doesn't 
matter whether the store_byte instruction would have executed atomically. 
This rule is needed in some cases for memory-mapped device registers.</span> 
</div>
<div class="paranum"><a name="p19.d">19.d/5</a></div>
<div class="Annotations"><span class="insert5"><B>Discussion:&nbsp;</B>The 
atomic reads and writes associated with accesses to nonatomic components 
of a full access object that is atomic are normal atomic operations &mdash; 
all of the rules that apply to other atomic operations apply to these 
as well. In particular, these atomic reads and writes are sequential 
if they apply to the same object.</span>&nbsp;</div>

<H4 Class="centered">Implementation Requirements</H4>
<div class="paranum"><a name="p20">20/5</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0439-1.TXT">AI12-0439-1</A></I>} 
<A NAME="I9612"></A>The external effect of a program (see <A HREF="AA-1-1-3.html">1.1.3</A>) 
is defined to include each read and update of a volatile or atomic object. 
The implementation shall not generate any memory reads or updates of 
atomic or volatile objects other than those specified by the program.<span class="insert5">&nbsp;However, there may be target-dependent cases where reading or writing 
a volatile but nonatomic object (typically a component) necessarily involves 
reading and/or writing neighboring storage, and that neighboring storage 
can overlap a volatile object.</span>&nbsp;</div>
<div class="paranum"><a name="p20.a">20.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>The presumption is that volatile 
or atomic objects might reside in an &ldquo;active&rdquo; part of the 
address space where each read has a potential side effect, and at the 
very least might deliver a different value.</div>
<div class="paranum"><a name="p20.b">20.b</a></div>
<div class="Annotations" style="margin-bottom: 0.4em">The rule above 
and the definition of external effect are intended to prevent (at least) 
the following incorrect optimizations, where V is a volatile variable: 
</div>
<div class="paranum"><a name="p20.c">20.c</a></div>
<div class="SmallBulleted">X:= V; Y:=V; cannot be allowed to be translated 
as Y:=V; X:=V;</div>
<div class="paranum"><a name="p20.d">20.d</a></div>
<div class="SmallBulleted">Deleting redundant loads: X:= V; X:= V; shall 
read the value of V from memory twice.</div>
<div class="paranum"><a name="p20.e">20.e</a></div>
<div class="SmallBulleted">Deleting redundant stores: V:= X; V:= X; shall 
write into V twice.</div>
<div class="paranum"><a name="p20.f">20.f</a></div>
<div class="SmallBulleted">Extra stores: V:= X+Y; should not translate 
to something like V:= X; V:= V+Y;</div>
<div class="paranum"><a name="p20.g">20.g</a></div>
<div class="SmallBulleted">Extra loads: X:= V; Y:= X+Z; X:=X+B; should 
not translate to something like Y:= V+Z; X:= V+B;</div>
<div class="paranum"><a name="p20.h">20.h</a></div>
<div class="SmallBulleted">Reordering of loads from volatile variables: 
X:= V1; Y:= V2; (whether or not V1 = V2) should not translate to Y:= 
V2; X:= V1;</div>
<div class="paranum"><a name="p20.i">20.i</a></div>
<div class="SmallBulleted">Reordering of stores to volatile variables: 
V1:= X; V2:= X; should not translate to V2:=X; V1:= X;&nbsp;</div>
<div class="paranum"><a name="p20.j">20.j/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
<span class="insert5">The part about &ldquo;target-dependent cases&rdquo; 
is intended to let compilers use a read-modify-write operation when a 
volatile component has a size that cannot be directly read or written 
with the available machine instructions. (For instance, writing a Boolean 
component with size 1 in a volatile packed array of Boolean requires 
a pre-read on most existing machines.)</span>&nbsp;</div>
<div class="paranum"><a name="p21">21/4</a></div>
<div class="Normal"><SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN><span class="delete4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
<span class="delete4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0001-1.TXT">AI12-0001-1</A></I>} 
<span class="delete4">If the Pack aspect is True for a type any of whose 
subcomponents are atomic, the implementation shall not pack the atomic 
subcomponents more tightly than that for which it can support indivisible 
reads and updates.</span>&nbsp;</div>
<div class="paranum"><a name="p21.a">21.a/4</a></div>
<div class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><span class="delete4"><B>Implementation Note: 
</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0009-1.TXT">AI05-0009-1</A></I>} 
<span class="delete4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0001-1.TXT">AI12-0001-1</A></I>} 
<span class="delete4">Usually, specifying aspect Pack for such a type 
will be illegal as the Recommended Level of Support cannot be achieved; 
otherwise, a warning might be appropriate if no packing whatsoever can 
be achieved.</span>&nbsp;</div>

<H4 Class="centered">Implementation Permissions</H4>
<div class="paranum"><a name="p21.1">21.1/5</a></div>
<div class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0282-1.TXT">AI12-0282-1</A></I>} 
<span class="insert5">Within the body of an instance of a generic unit 
that has a formal type <I>T</I> that is not atomic and an actual type 
that is atomic, if an object <I>O</I> of type <I>T</I> is declared and 
explicitly specified as atomic, the implementation may introduce an additional 
copy on passing <I>O</I> to a subprogram with a parameter of type <I>T</I> 
that is normally passed by reference. A corresponding permission applies 
to volatile parameter passing.</span>&nbsp;</div>

<H4 Class="centered">Implementation Advice</H4>
<div class="paranum"><a name="p22">22/5</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00259.TXT">AI95-00259-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
A load or store of a volatile object whose size is a multiple of System.Storage_Unit 
and whose alignment is nonzero, should be implemented by accessing exactly 
the bits of the object and no others<span class="insert5">, except in 
the case of a volatile but nonatomic subcomponent of an atomic object</span>. 
</div>
<div class="paranum"><a name="p22.a">22.a/2</a></div>
<div class="Annotations"><B>Implementation Advice:&nbsp;</B>A load or store 
of a volatile object whose size is a multiple of System.Storage_Unit 
and whose alignment is nonzero, should be implemented by accessing exactly 
the bits of the object and no others.</div>
<div class="paranum"><a name="p22.b">22.b/5</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
Since any object can be a volatile object, including packed array components 
and bit-mapped record components, we require the above only when it is 
reasonable to assume that the machine can avoid accessing bits outside 
of the object.<span class="insert5">&nbsp;The exception is needed so this 
advice doesn't conflict with other rules of this subclauase.</span>&nbsp;</div>
<div class="paranum"><a name="p22.c">22.c/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This implies that the load 
or store of a volatile object that meets the above requirement should 
not be combined with that of any other object, nor should it access any 
bits not belonging to any other object. This means that the suitability 
of the implementation for memory-mapped I/O can be determined from its 
documentation, as any cases where the implementation does not follow 
Implementation Advice must be documented.&nbsp;</div>
<div class="paranum"><a name="p23">23/2</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00259.TXT">AI95-00259-01</A></I>} 
A load or store of an atomic object should, where possible, be implemented 
by a single load or store instruction.&nbsp;</div>
<div class="paranum"><a name="p23.a">23.a/2</a></div>
<div class="Annotations"><B>Implementation Advice:&nbsp;</B>A load or store 
of an atomic object should be implemented by a single load or store instruction.</div>
<div class="paranum"><a name="p24">24</a></div>
<div class="Notes">NOTE 1&nbsp;&nbsp;&nbsp;An imported volatile or atomic 
constant behaves as a constant (i.e. read-only) with respect to other 
parts of the Ada program, but can still be modified by an &ldquo;external 
source&rdquo;.</div>
<div class="paranum"><a name="p25">25/4</a></div>
<div class="Notes">NOTE 2&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0001-1.TXT">AI12-0001-1</A></I>} 
<span class="insert4">Specifying the Pack aspect cannot override the 
effect of specifying an Atomic or Atomic_Components aspect.</span></div>
<div class="paranum"><a name="p26">26/5</a></div>
<div class="Notes">NOTE 3&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
<span class="insert5"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0440-1.TXT">AI12-0440-1</A></I>} 
<span class="insert5">When mapping an Ada object to a memory-mapped hardware 
register, the Ada object can be declared atomic to ensure that the compiler 
will read and write exactly the bits of the register as specified in 
the source code and no others.</span></div>
<div class="paranum"><a name="p26.a">26.a/5</a></div>
<div class="Annotations"><span class="insert5"><B>Discussion:&nbsp;</B>This 
is especially important for a write-only hardware register, as in such 
a case a read-modify-write cycle will not work. The only time the language 
guarantees such a cycle will not happen is when writing an entire atomic 
object. If one wants to write individual components of a write-only hardware 
register (assuming the hardware supports that), those also need to be 
declared atomic.</span>&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<div class="paranum"><a name="p26.b">26.b</a></div>
<div class="Annotations"><A NAME="I9613"></A>Pragma Atomic replaces Ada 
83's pragma Shared. The name &ldquo;Shared&rdquo; was confusing, because 
the pragma was not used to mark variables as shared.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum"><a name="p26.c">26.c/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00259.TXT">AI95-00259-01</A></I>} 
Added Implementation Advice to clarify the meaning of Atomic and Volatile 
in machine terms. The documentation that this advice applies will make 
the use of Ada implementations more predictable for low-level (such as 
device register) programming.</div>
<div class="paranum"><a name="p26.d">26.d/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00272.TXT">AI95-00272-01</A></I>} 
Added wording to clarify that a slice of an object of an atomic type 
is not atomic, just like a component of an atomic type is not (necessarily) 
atomic.&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 2005</H4>
<div class="paranum"><a name="p26.e">26.e/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0218-1.TXT">AI05-0218-1</A></I>} 
<A NAME="I9614"></A><B>Correction:</B> Plugged a hole involving volatile 
components of formal types when the formal type's component has a nonvolatile 
type. This was done by making certain actual types illegal for formal 
derived and formal array types; these types were allowed for Ada 95 and 
Ada 2005.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 2005</H4>
<div class="paranum"><a name="p26.f">26.f/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0009-1.TXT">AI05-0009-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
<A NAME="I9615"></A>Aspects Independent and Independent_Components are 
new; they eliminate ambiguity about independent addressability.</div>
<div class="paranum"><a name="p26.g">26.g/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
Aspects Atomic, Atomic_Components, Volatile, and Volatile_Components 
are new; <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
Atomic, Atomic_Components, Volatile, and Volatile_Components are now 
obsolescent.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2005</H4>
<div class="paranum"><a name="p26.h">26.h/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0117-1.TXT">AI05-0117-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0275-1.TXT">AI05-0275-1</A></I>} 
Revised the definition of volatile to eliminate overspecification and 
simply focus on the root requirement (that all tasks see the same view 
of volatile objects). This is not an inconsistency; &quot;memory&quot; 
arguably includes on-chip caches so long as those are kept consistent. 
Moreover, it is difficult to imagine a program that could tell the difference.</div>
<div class="paranum"><a name="p26.i">26.i/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0142-4.TXT">AI05-0142-4</A></I>} 
Added wording to take explicitly aliased parameters (see <A HREF="AA-6-1.html">6.1</A>) 
into account when determining the legality of parameter passing of volatile 
and atomic objects.&nbsp;</div>

<H4 Class="centered">Inconsistencies With Ada 2012</H4>
<div class="paranum"><a name="p26.j">26.j/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0128-1.TXT">AI12-0128-1</A></I>} 
<span class="insert5"><A NAME="I9616"></A> Required that nonatomic components 
of a atomic object use a read-modify-write cycle, as well as clarifying 
that such a cycle is allowed for volatile objects that aren't exactly 
the size of a machine scalar. That can introduce a read-modify-write 
cycle where one was not used previously (for instance, if the components 
are exactly byte-sized on most machines); it is thought that this will 
more often fix bugs with access to hardware than it will cause them. 
If this is an issue, declaring the components themselves as atomic will 
restore the previous behavior.</span>&nbsp;</div>

<H4 Class="centered">Extensions to Ada 2012</H4>
<div class="paranum"><a name="p26.k">26.k/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0282-1.TXT">AI12-0282-1</A></I>} 
<span class="insert5"><A NAME="I9617"></A>These aspects now can be specified 
for generic formal types.</span></div>
<div class="paranum"><a name="p26.l">26.l/5</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0363-1.TXT">AI12-0363-1</A></I>} 
<span class="insert5">Aspect Full_Access_Only is new; it can be used 
to guarantee access to a complete device register for any operation even 
when the register is mapped to a number of components.</span>&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2012</H4>
<div class="paranum"><a name="p26.m">26.m/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0001-1.TXT">AI12-0001-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Clarified that aliased objects 
are considered to be specified as independently addressable, and also 
eliminated an unnecessary rule.</span>&nbsp;</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-6-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
