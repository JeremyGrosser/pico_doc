=== 1.6.0
_Next release_

==== New features

===== GPIO drive strength
`RP.GPIO.Configure` now takes a `Drive` argument to control GPIO drive strength, up to 12mA per pin. This should be used with caution as the sum of all current sourced or sinked by GPIO and QSPI pins may not exceed 50mA.

===== New unit tests
New unit tests were added for GPIO interrupts, DMA interrupts, and RP.Reset timeouts.

===== Coverage test script is more reliable
The coverage test script will now exit and report an error if any build or test step fails. Test output is printed after completion, regardless of error status.

==== Bugs fixed

===== Fixed warnings about unused units
The Alire 1.2.0 release candidate enables a few warnings that were previously ignored. These warnings were fixed by removing references to unused units.

===== DMA pacing timer tests were never run
The DMA pacing timer test was added to the test suite incorrectly and were never being run. This test is now enabled and needed some minor fixes to pass. No changes to the DMA driver were needed.

===== RP.PIO.Get would block forever
The Get procedure was incorrectly inverting the FIFO status register when polling to determine if there was data available. This caused it to block indefinitely if called while there was data in the FIFO. The FSTAT register type has been redefined to clarify the use of these registers and prevent this type of error in the future.

=== 1.5.0
May 2, 2022

==== New features

===== Dynamic clock configuration
RP.Clock now exposes procedures for configuring the PLLs and changing the system clock source. Predefined PLL_Config constants are provided for common operating frequencies up to 250 MHz. While changing the system clock is now possible, it is not currently recommended. Several unit tests are currently failing with non-default clock configuration and reconfiguring peripherals after changing the clock frequency is expected to cause problems. We expect to fix these issues in the near future.

===== RTC delays
The RTC can now be used to delay until a specific time and date with https://github.com/JeremyGrosser/rp2040_hal/blob/8dd05895a816dba9c047cde4e3726062b599caa5/src/drivers/rp-rtc.ads#L38[RP.RTC.Delay_Until]. The RTC should be configured before calling Delay_Until. The RTC is accurate to within a second and synchronization between the RTC and CPU clocks may add approximately 42 microseconds before and after the delay.

===== PWM DMA helper
`RP.PWM.Compare_Reg_Address` returns the address of the compare register. This address can be set as the destination of a DMA transfer to very quickly modulate PWM output (to generate audio, for example). The compare register is 32 bits wide, containing two 16 bit values, channel A in the low bits and channel B in the high bits. If you configure DMA for 16 bit transfers, the same value will be written to both channels simultaneously. There is no way to write one PWM channel without modifying the other with DMA.

==== Breaking changes

===== RP.SysTick has been removed
While testing new clock configurations, I discovered that the SysTick tests have been broken since commit cec9af51c9eb86b8daf7c37f79b4fb9221e1ecfe. The SysTick interrupt was not firing as expected, so the `RP.SysTick.Delay_Until` procedure would hang indefinitely. 

The fix would be to enable the SysTick IRQ (15) in the NVIC. However, when I tried to do this, the PendSV interrupt was also triggered, which led to a crash because this interrupt is not defined. PendSV is meant to be used by an RTOS to implement context switching, so we don't really want to provide a handler for it in the rp2040_hal library.

I've chosen to remove RP.SysTick from rp2040_hal, rather than fix the interrupt for the following reasons:

 - SysTick's CVR and RELOAD registers are too small to accomodate a 1 KHz tick rate with a 250 MHz system clock, which we want to support.
 - Most ARM Cortex-M compatible RTOS libraries will configure SysTick and PendSV on their own, conflicting with rp2040_hal's implementation.
 - SysTick doesn't do anything that we can't already do with RP.Timer.

===== RP_Interrupts implments weak handlers for all user interrupts
crt0.S defines a weak `isr_irqN` symbol for every user interrupt. Previously, the default handler for these interrupts would call the `bkpt` instruction, causing a debug break or reset if no debugger is attached.

Now, the `isr_irqN` symbols are defined as weak references to `__gnat_irq_trap` which is implemented by `RP_Interrupts.Interrupt_Request_Handler`. This handler does a lookup into an array of `access procedure` populated by calls to `RP_Interrupts.Attach_Handler`. If no handler is defined for an interrupt, the `Program_Error` exception is raised with a descriptive message. As ZFP runtimes do not allow exceptions to propagate, this will result in a reset.

If you need to define a custom interrupt handler, you can either use `RP_Interrupts.Attach_Handler` or export one of the `isr_irqN` symbols with the `External_Name` aspect. See the https://github.com/JeremyGrosser/pico_examples/tree/master/uart_interrupt/src[uart_interrupt example].

=== 1.4.1
April 2, 2022

==== Bugs fixed

===== ROM weak symbols were overridden by the toolchain
The ROM `__aeabi` symbols were made weak in order to allow users to override them, but this caused the toolchain's symbols to take precedence. The change to make these symbols weak has been reverted with this release.

=== 1.4.0
April 2, 2022

==== New features

===== Multicore operation
The https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-multicore.ads[RP.Multicore], https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-multicore-spinlocks.ads[RP.Multicore.Spinlocks], and https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-multicore-fifo.ads[RP.Multicore.FIFO] packages expose the second CPU core and the inter-core locking primitives. https://github.com/JeremyGrosser/pico_examples/tree/master/multicore/src[An example] application uses the FIFO to signal core 1 to toggle an LED. Previously, multicore operation was only supported by the Ravenscar runtimes. These packages work with ZFP runtimes.

Note that many of the drivers in rp2040_hal are not safe for concurrent access and debugging race conditions between cores can be difficult. If you run into problems, try limiting access to a peripheral to one core at a time, or guard accesses with the spinlocks.

Thanks to https://github.com/Fabien-Chouteau[@Fabien-Chouteau] for contributing the multicore drivers.

===== UART and SPI interrupts
The RP.UART and RP.SPI drivers now have procedures for enabling and reading peripheral interrupt flags. These interrupts may trigger system-level interrupts or you might just poll the flags functions as needed. Thanks to https://github.com/Fabien-Chouteau[@Fabien-Chouteau] for these changes.

===== Flash cache control
Normally, all reads from the external QSPI flash use a read-through cache. The https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-flash-cache.ads[RP.Flash.Cache] package can disable and flush the cache. Cache access and hit counters can provide information on cache performance. Disabling the cache may be useful if you need deterministic timing to do performance measurements or reduce jitter. If you plan to put the chip to sleep for a long period of time, the `RP.Flash.Cache.Power_Down` procedure may reduce power consumption further.

===== ROM initialization with Ravenscar
The `rp_rom_float_initialize` symbol has been renamed to `__gnat_initialize_bootrom`, for better compatibility with Ravenscar's startup routines.

==== Bugs fixed

===== RP.PIO.WS2812 reset the PIO
When `RP.PIO.WS2812.Initialize` was called, it would reset the entire PIO peripheral, meaning this driver could not be used concurrently with other PIO programs.

===== RP.PIO.WS2812 RGB bit order
RGB color values were not encoded correctly when the `Set_RGB` procedure was used.

=== 1.3.0
February 28, 2022

==== New features

===== DMA Setup can be performed without triggering a transfer
When chaining DMA channels, it's often useful to set the From and To addresses of a channel without triggering it immediately. Previously, RP.DMA.Start both set these addresses and triggered a transfer. Now, RP.DMA.Setup performs this configuration and RP.DMA.Start with only a Channel argument will trigger the transfer. If From, To, and Count are passed as arguments to Start, then the old behavior is maintained.

Note that if Increment_Read or Increment_Write are True, then repeated calls to RP.DMA.Start will *not* reset the From and To addresses, they will continue from where the last transfer left off, unless Ring_Wrap and Ring_Size are configured for the DMA channel.

===== SysTick Delay_Until
The SysTick driver now has a Delay_Until procedure with functionality similar to `RP.Timer.Delay_Until`. All SysTick delays are tested to be accurate within +/- 1ms.

===== Flash programming
The https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-flash.ads[RP.Flash] package can erase and program the flash chip connected to the RP2040's XIP interface, which is where code executes from. Note that Erase must be called before Program. See https://github.com/JeremyGrosser/rp2040_hal/blob/master/tests/src/flash_tests.adb[tests/src/flash_tests.adb] for example usage.

Thanks to Fabien Chouteau for https://github.com/JeremyGrosser/rp2040_hal/issues/10[contributing this driver].

===== PIO instruction encoding
The https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-pio-encoding.ads[RP.PIO.Encoding] package contains a record with representation clause for each PIO opcode. The `Encode` function returns `PIO_Instruction` which can be used to fill a `RP.PIO.Program` array. See the https://github.com/JeremyGrosser/pico_examples/blob/master/pio_assemble/src/main.adb[pio_assemble] example.

===== WS2812B and Audio_I2S drivers
A https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-pio-ws2812.ads[PIO program] that implements the wire protocol for WS2812 RGB LEDs has been added as a child package of RP.PIO. The Audio_I2S driver was moved to rp2040_hal from pico_bsp.

===== Testing enhancements
New unit tests for SPI, RTC, and Flash functions were added. https://docs.adacore.com/gnatcoverage-docs/html/gnatcov.html[GNATcoverage] is now supported for tests and reports 52% https://docs.adacore.com/gnatcoverage-docs/html/gnatcov/cov_source.html#core-notions-and-reporting-level-stmt-decision[stmt+decision] coverage for rp2040_hal.

==== Bugs fixed

===== I2C Mem_Write sent a repeated start after the address
The I2C Mem_Write procedure was sending a repeated start between the memory address and the data to be written. This caused issues for some I2C EEPROMs. Mem_Write has been changed to send the memory address and data both in one Master_Transmit call.

Thanks to Holger Rodriguez for reporting https://github.com/JeremyGrosser/rp2040_hal/issues/33[this issue].

===== SysTick returned incorrect values
`RP.SysTick.Clock` was returning the value of the `CURRENT` register, not the ticks counted by the 1ms interrupt handler. `RP.SysTick.Clock` now returns the ticks value, which is the number of milliseconds since SysTick was enabled.

===== RP.RTC.Get_Date was out of range
Get_Date would throw a ConstraintError if the hardware RTC year was 0.

===== RP.ROM.Floating_Point used V2 boot ROM
RP.ROM.Floating_Point did not check the boot ROM version before calling functions that are only available in V2. These calls have been removed.

- int642float
- uint642float
- float2int64
- float2uint64
- float2double

===== boot2 license clarification
The boot2 directory contained source code that included a GPLv3 with runtime exception license in a comment header. These files were copied from a pull request to bb-runtimes that has not been merged. Daniel King (the original author of these files) gave permission to relicense as BSD-3-Clause, in line with the rest of rp2040_hal.

=== 1.2.1
February 1, 2022

==== Bugs fixed

===== RP.ROM.Floating_Point used C_float
The use of C_float in the spec for RP.ROM.Floating_Point required quite a bit of type casting to/from Float in normal use. The public interface of RP.ROM.Floating_Point has been changed to use the Float type and conversions to/from C_float are performed in the package body.

=== 1.2.0
February 1, 2022

==== New features

===== External clock output
The RP2040 can expose any of the internal clocks to an external pin. For example,
[source,ada]
----
with RP.Clock; use RP.Clock;
with RP.GPIO;
with Pico;

procedure Main is
begin
    RP.GPIO.Configure (Pico.GP21, RP.GPIO.Pull_Up, RP.GPIO.CLOCK);
    Set_Source (GPOUT0, SYS);
    Enable (GPOUT0);
end Main;
----
See *1.4.3 GPIO_Functions* in the RP2040 datasheet to determine the mapping between GPOUT channels and GPIO pins. I didn't add a lookup table for this mapping to RP.Clock as that would introduce a dependency on RP.GPIO, which may be undesirable.

===== DMA pacing timers
The DMA peripheral has four internal timers that can be configured as a trigger source for any DMA channel. These pacing timers have a fractional divider connected to clk_sys. The trigger rate is defined as `clk_sys * (X / Y)`. X and Y are 32 bit unsigned integers and can be configured with the new `RP.DMA.Set_Pacing_Timer` procedure.

===== ROM floating point
The `RP.ROM` and `RP.ROM.Floating_Point` packages have undergone a significant refactor that enables the use of the ROM floating point library in lieu of gcc's soft float functions in most cases.

The `RP.ROM.rom_id` symbol has been removed, as it pointed to an incorrect value. `RP.ROM.Header.Version` and `RP.ROM.Header.Magic` should be used to identify the ROM instead.

`src/startup/crt0.S` *must* branch to the `rp_rom_float_initialize` after copying .data and .bss but before calling any other initialization. If you have copied or modified `crt0.S` in your project, you will need to integrate these changes.

The `rom_hword_as_ptr` symbol has been removed. We now use a `type Short_Address` to represent the ROM's lookup table offsets and convert it to `System.Address` where needed. This is an implementation detail and shouldn't affect users of this library.

===== Frequency counter accuracy
`RP.Clock.Frequency` now has two optional arguments: `Rounded : Boolean` and `Accuracy : UInt4`. The default behavior enables rounding and maximum accuracy, making the frequency counter results very stable. This replicates the behavior of pico-sdk. If rounding is disabled, then the counter results include some error, between 64 Hz and 2048 KHz, depending on the value of Accuracy. Higher values for Accuracy increase the counter sampling time.

==== Bugs fixed

===== RTC drift
The RTC's internal divider value was off by one. The RTC should drift a lot less now.

===== RP.ADC.Disable did not disable clk_adc
To save power, clk_adc is now disabled whenever the ADC peripheral is disabled.

=== 1.1.0
January 7, 2022

==== New features

===== Interrupt proxy
Interrupts are now proxied through the `RP_Interrupts` package, which is only included if the configuration `Use_Startup = true`, which is the default. This means the drivers can now be used with a Ravenscar runtime or other RTOS without clobbering the runtime's interrupt handlers.

===== Build mode is now set to optimize by default
Previously, debug symbols were included in every build and optimization was disabled by default. Now that we're calling this a stable release, debug mode on every build seems unnecessary.

===== Dependencies only use the major version
Up to this point, the version numbers of rp2040_hal, pico_bsp, and pico_examples were kept in sync. Now that we have a stable release, it's not necessary to bump the BSP and examples for every release. Therefore, pico_bsp has been updated to depend on version `^1` of rp2040_hal, meaning any 1.x.x release. Similarly pico_examples depends on `^1` of pico_bsp. rp2040_hal has also been updated to depend on the major and minor versions of its dependencies, eg. `gnat_arm_elf = "^11.2"`.

==== Bugs fixed

===== SPI Transmit returned too early
If `Blocking = True`, RP.SPI.Transmit should not return before the last bit is clocked out. The `Transmit_Status` function was only testing the FIFO status registers, but not testing the `SSPSR.BSY` flag, which indicates that the SPI clock is active. A new `Busy` state has been added to the `SPI_FIFO_Status` enum and the `Transmit_Status` and `Receive_Status` functions have been updated to test for it.

===== UART Transmit returned too early
Effectively the same bug as SPI.

=== 1.0.0
December 26, 2021

==== New features

===== DMA IRQ management
`RP.DMA` can now configure interrupt masks for each DMA channel. If `DMA_Configuration.Quiet = False`, the interrupt will fire when a transfer is completed.

===== Unit tests
We've begun writing tests for rp2040_hal with the https://docs.adacore.com/live/wave/aunit/html/aunit_cb/aunit_cb.html[AUnit Testing Framework]. Currently, there are tests for Clock, UART, SPI, GPIO, and DMA. These tests have already led to several bug fixes and we will continue to work toward more complete unit test coverage.

==== Breaking changes
None.

==== Bugs fixed

===== GPIO.Mode returned incorrect values
GPIO.Mode was returning the mode of the wrong pin.

===== PWM divider edge cases
The minimum and maximum PWM divider values were calculated incorrectly. The calculation and constraints on `RP.PWM.Divider` have been fixed.

===== RP.DMA.Status returned incorrect Transfers_Remaining
The DMA alias register layouts were incorrect. The only visible effect of this error was that RP.DMA.Status returned an incorrect value for Transfers_Remaining.

===== Some DMA triggers didn't work
The DREQ register values did not have a representation clause specified, which caused triggers internal to the DMA peripheral (pacing timers and permanent triggers) to be nonfunctional.

=== 0.7.0
October 26, 2021

==== New features

===== Documentation
Documentation has been written for most of the drivers and is available at https://pico-doc.synack.me/[pico-doc.synack.me].

===== USB device controller
The `RP.USB_Device` driver implements the `USB.HAL.Device.USB_Device_Controller` interface. This adds a dependency on the https://github.com/Fabien-Chouteau/usb_embedded[usb_embedded] crate, which in turn depends on https://github.com/Fabien-Chouteau/bbqueue-spark[bbqueue-spark] and https://github.com/Fabien-Chouteau/atomic[atomic]. This driver does not support USB host mode or double buffering.

The upstream SVD was updated to include USB_DPRAM registers, so all of the RP2040_SVD packages have been regenerated from source.

===== ADC round robin and free running mode
xref:round_robin[RP.ADC.Set_Round_Robin] can be used to select multiple ADC channels to be read sequentially. xref:continuous_conversion[RP.ADC.Set_Mode (Free_Running)] will cause the ADC to continuously sample the selected channels. Paired with DMA, this means the ADC can run at up to 500,000 samples per second.

===== Ada boot2 code
Thanks to https://github.com/damaki[Daniel King], we have a working implementation of xref:boot_code[boot2 in Ada]. boot2 has been moved from pico_bsp to rp2040_hal and the flash chip may be selected with the `Flash_Chip` Alire configuration variable.

===== PWM duty cycle may be set for one channel at a time
`RP.PWM.Set_Duty_Cycle` takes a `Channel` argument so that a single PWM channel's duty cycle may be updated without affecting the other. If `Channel` is not specified, the duty cycle for both channels must be specified.

===== Default values for SPI and UART configuration
`Default_SPI_Configuration` and `Default_UART_Configuration` constants are available and are used if no arguments are supplied to `RP.SPI.Configure` or `RP.UART.Configure`.

===== SysTick improvements
`RP.SysTick.Clock` reports the 24-bit monotonic counter.

===== PIO interrupts
`RP.PIO` includes procedures for configuring and using interrupts from the PIO peripheral. Thanks to @Fabien-Chouteau for contributing these changes.

==== Breaking changes

===== Initialization procedures renamed
In order to make driver usage more consistent, the following procedures have been renamed:

- RP.I2C_Master.Enable -> RP.I2C_Master.Configure
- RP.RTC.Initialize -> RP.RTC.Configure

===== Toolchain dependency
rp2040_hal depends on the `gnat_arm_elf` toolchain in Alire. While the GNAT Community toolchains should continue to work, the FSF GNAT toolchain is the only one we will test going forward.

===== Startup code conflicts with Ravenscar runtimes
`crt0.S` and `package Runtime` have been moved from pico_bsp into rp2040_hal. If rp2040_hal is used as a dependency of a project built with one of the Ravenscar runtimes, rp2040_hal's startup code will conflict with that provided by the runtime. The `Use_Startup = false` Alire configuration variable will prevent rp2040_hal from compiling and linking it's startup code.

==== Bugs fixed

===== Oscillator startup delay for Feather boards
Some Adafruit Feather RP2040 boards have higher than expected capacitance on the XOSC traces and need a bit more time for the oscillator to stabilize. The `XOSC_Startup_Delay` parameter was added to `RP.Clock.Initialize` to allow BSPs to override the default startup delay. The default value should still be fine for most boards.

===== Clarify PWM frequency range
`RP.PWM.Set_Frequency` has a precondition that fails if a frequency that cannot be represented by the clock divider is requested.

===== Fixed crash when maximum PWM divider is specified
If `Divider'Last` was passed to `RP.PWM.Set_Divider`, the fixed point value would be rounded rather than truncated when calculating the integer part of the divider. This edge case has been fixed.

===== PIO relative JMP instruction addressing
If a PIO program is loaded at an offset other than zero, the JMP instructions need to be modified to point to the correct addresses. `RP.PIO.Load` does this rewriting. Thanks to @Fabien-Chouteau for this fix!

===== RP.Timer.Clock could get stuck in an infinite loop
Fix contributed by @Fabien-Chouteau.

=== 0.6.0
September 12, 2021

==== New features

===== Clocks can be disabled
To save power, peripheral clocks can be disabled with `RP.Clock.Disable`. Some peripherals may exhibit unexpected behavior if their clocks are disabled. Use at your own risk.

===== RTC can be paused
The `RP.RTC.Pause` and `RP.RTC.Resume` procedures stop and start the RTC. This is useful if you want the RTC to stop ticking while a user is setting the time. Preconditions requiring the clock to be running have been removed from the RTC procedures. `RP.RTC.Initialize` still needs to be called at least once, but can be skipped if `RP.RTC.Running` returns `True`, implying that the RTC is already Initialized.

===== Continuous integration
A CircleCI project has been setup to compile `rp2040_hal` upon commit and email the author if the build fails. This is not meant to replace actual user testing on real hardware. This is just a quick check for broken builds.

==== Breaking changes

===== Delay_Microseconds no longer uses interrupts
`RP.Timer.Delay_Microseconds` polls the timer registers in a busy loop, rather than setting up an alarm interrupt. This should make shorter (< 10 microsecond) delays more accurate as interrupt latency is no longer a factor. `RP.Timer.Delay_Until` can still be used to perform interrupt-based delays with microsecond precision.

==== Bugs fixed

===== 16-bit RP.SPI.Transmit did not respect the Blocking configuration option
https://github.com/JeremyGrosser/rp2040_hal/issues/3[Issue #3]: If Blocking was set in the SPI_Configuration and the 16-bit version of the Transmit procedure was used, Transmit would return before all data was clocked out. Thanks to https://github.com/hgrodriguez[@hgrodriguez] for discovering this 

===== RP.PWM did not check that Initialize was called first
If RP.PWM.Initialize was not called before configuring PWM slices, the configuration would succeed but would generate no output. An `Initialized` variable has been added to RP.PWM along with a precondition on all procedures that modify PWM slices to ensure that `Initialized` is True. If you forget to call RP.PWM.Initialize, your program will crash on the first run.

===== RP.ADC.Temperature could return incorrect data
If `RP.ADC.Configure (Temperature_Sensor)` was not called before `RP.ADC.Temperature`, incorrect temperature readings would be returned. `RP.ADC.Temperature` now ensures the temperature sensor is configured on every call, eliminating the need to call Configure for the temperature sensor.

=== 0.5.0
July 19, 2021

==== New features

===== UART enhancements
https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-uart.ads[RP.UART] now allows configuration of baud, word size, parity, and stop bits via the UART_Configuration record. The default values for the UART_Configuration record represent the typical `115200 8n1` setup.

The UART now has a `Send_Break` procedure, which holds TX in an active state (usually low) for at least two frame periods. Some protocols use the https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#Break_condition[UART break condition] to indicate the start of a new packet.

`RP.UART.Receive` now sets `Status = Busy` and returns immediately if a break condition is detected.

UART Transmit and Receive procedures now return as soon as all words have been delivered to the FIFO. FIFO status is exposed by the Transmit_Status and Receive_Status functions. This interface is the same as the I2C and SPI drivers.

The https://github.com/JeremyGrosser/pico_examples/blob/master/uart_echo/src/main.adb[uart_echo] example has been updated to demonstrate these new features.

===== RTC driver
The real time clock is now exposed by the https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-rtc.ads[RP.RTC] package. It implements the https://github.com/Fabien-Chouteau/hal/blob/master/src/hal-real_time_clock.ads[HAL.Real_Time_Clock] interface for getting and setting the date and time. An https://github.com/JeremyGrosser/pico_examples/blob/master/rtc/src/main.adb[example project] demonstrates use of the RTC. RTC alarm interrupts are not yet implemented.

===== Interpolator driver
The RP2040 has two interpolators per core embedded in the SIO peripheral. The https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-interpolator.ads[RP.Interpolator] package make their registers available. Some of the registers in this block support single-cycle operation, so it would be counter productive to wrap them up in procedures that may not be inlined by the compiler. There are examples in the datasheet for working with the interpolators, but I'm still trying to wrap my head around it, so there is no example here yet.

==== Breaking changes

===== UART.Enable is replaced with UART.Configure
To match the nomenclature of the other serial drivers (SPI, I2C), https://github.com/JeremyGrosser/rp2040_hal/blob/master/src/drivers/rp-uart.ads[RP.UART] now has a Configure procedure instead of Enable.

===== I2C addresses should include the R/W bit
The RP.I2C driver was expecting 7-bit I2C addresses to not include the R/W bit in the LSB. This was inconsistent with the other HAL.I2C implementations and would result in incorrect I2C addressing. Now, 7-bit I2C addresses should be represented as a UInt8 with the LSB set to 0. If this breaks your code, shift your I2C address left by one bit.

==== Bugs fixed

===== Improper use of the Pack clause
The `Pack` clause was used to enforce the memory layout of some records.

> It is important to realize that pragma Pack must not be used to specify the exact representation of a data type, but to help the compiler to improve the efficiency of the generated code. https://en.wikibooks.org/wiki/Ada_Programming/Pragmas/Pack#Exact_data_representation[Source]

The Pack clause has been replaced with `Component_Size` and `Size` clauses where necessary. Thanks to https://github.com/onox[@onox] for pointing this out!

===== Use of access PIO_Device as a type discriminant
Projects depending on pico_bsp failed gnatprove in SPARK mode as the `Pico.Audio_I2S` package was using `not null access PIO_Device` as a discriminant. PIO_Device is now `tagged` and `Pico.Audio_I2S` uses `not null access PIO_Device'Class`, which is valid under SPARK. gnatprove still throws many warnings about side effects in the `rp2040_hal` drivers, but no fatal errors.

===== RP.ADC.Read_Microvolts was rounding incorrectly
`Read_Microvolts` was using Integer arithmetic to calculate `VREF / Analog_Value'Last`, which does not divide evenly for common VREF values. When that value was multiplied by an ADC reading, Read_Microvolts would return lower than expected results. Read_Microvolts now uses floating point to multiply ADC counts before converting the return value to Integer.

===== UART Transmit and Receive did not respect Timeout
The UART driver has been modified to use RP.Timer to implement timeouts and monitor FIFO status, similar to RP.SPI and RP.I2C.

===== SPI Transmit was nonblocking
The SPI Transmit procedure would return immediately after the last byte was written to the FIFO, but before the FIFO became empty. This behavior breaks some drivers that depend on all bytes being clocked out before proceeding. A configuration flag for Blocking behavior has been added and defaults to True.

=== 0.4.0
June 11, 2021

==== New features

===== DMA driver
The RP.DMA package allows out of band copies between a source and target System.Address and may be triggered by a variety of events. The PIO and SPI drivers have been tested with DMA and have new functions that return their FIFO addresses.

===== I/O Schmitt triggers
The RP.GPIO.Configure procedure now takes optional https://en.wikipedia.org/wiki/Schmitt_trigger[Schmitt] and https://en.wikipedia.org/wiki/Slew_rate[Slew_Fast] boolean parameters that control the behavior of I/O pads. The RP2040 documentation recommends enabling the Schmitt trigger for I2C operation.

===== RP.ROM.Floating_Point
The ROM floating point library is now exposed in the RP.ROM.Floating_Point package. GNAT will use gcc's soft float implementation by default, but you may call the optimized versions in the ROM directly. The Ravenscar runtimes will replace the gcc functions with these ROM calls automatically.

===== I2C and SPI Timeouts
Previously, the I2C and SPI drivers did not use the Timeout argument. They now use RP.Timer to implement a timeout for all blocking operations and set Status to Err_Timeout if it expires before the blocking operation completes. The I2C peripheral may require a reset after a timeout as the bus may be in an unknown state.

===== SPI FIFO status is exposed with Transmit_Status and Receive_Status
You can use these functions to determine if the Transmit or Receive procedures would block. See the new spi_loopback example.

==== Breaking changes

===== PWM Set_Duty_Cycle and Set_Invert no longer use PWM_Point
These procedures have changed to take a PWM_Slice as the first argument to make them more consistent with the rest of the driver. These procedures now set both channels of a slice nearly simultaneously.

===== PWM Initialize must be called before any other PWM configuration
This procedure was added to fix the corruption bug discussed below.

===== SPI.Enable is replaced with SPI.Configure
The Configure procedure takes a SPI_Configuration record as an argument for easy static configuration.

==== Bugs fixed

===== PWM configuration is corrupted after power cycle
RP.PWM.Enable is called after configuring a PWM slice to enable it. This procedure was incorrectly resetting the PWM peripheral before enabling the slice. RP.PWM.Initialize now performs the reset and all peripheral resets have been moved to RP.Reset to avoid this mistake in the future.

===== PWM dividers can have a value of zero
The documentation is unclear on what this means, but my testing shows that it acts like a divider of 1, which outputs the clk_sys frequency.

===== Fast I2C writes would result in dropped bytes
The RP.I2C_Master driver has been modified to wait for the TX FIFO to be empty before writing a byte. This effectively reduces the FIFO depth to 1 byte. This is the same behavior as the upstream SDK.

==== Known issues

===== I2C clock is slower than expected
In 400 KHz (fast mode) operation, the I2C master generates SCL at approximately 380 KHz. I believe this is due to clock stretching caused by the new TX FIFO blocking behavior. The upstream SDK has the same behavior. According to the I2C specification, a fast mode clock may be *up to* 400 KHz, but specifies no minimum frequency. It may be possible to workaround this by using DMA to write to the I2C FIFO, but this is untested.
